<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>1024子翔的程序人生</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-11T09:18:58.928Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Choicelin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>wepy开发速查手册</title>
    <link href="http://yoursite.com/2018/03/11/wepy%E5%BC%80%E5%8F%91%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/"/>
    <id>http://yoursite.com/2018/03/11/wepy开发速查手册/</id>
    <published>2018-03-11T08:25:24.000Z</published>
    <updated>2018-03-11T09:18:58.928Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>事件bindtap=”click”替换为@tap=”click”,防止冒泡@tap.stop,防止捕获@tap.capture.stop，如果是@someEvent.user=”somefunction”，这种通过this.$emit(‘someEvent’),someFunction写在父组件methods里面，同时父组件events加入someEvent</p><p>events示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// events对象中所声明的函数为用于监听组件之间的通信与交互事件的事件处理函数</span></span><br><span class="line">    events = &#123;</span><br><span class="line">        <span class="string">'someEvent'</span>: <span class="function">(<span class="params">p1, p2, p3, $event</span>) =&gt;</span> &#123;</span><br><span class="line">               <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.$name&#125;</span> receive <span class="subst">$&#123;$event.name&#125;</span> from <span class="subst">$&#123;$event.source.$name&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>事件传参变更，bindtap=”click” data-index=”“更改为@tap=”click()”</p></li><li><p>repeat使用实例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注意，使用for属性，而不是使用wx:for属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repeat</span> <span class="attr">for</span>=<span class="string">"&#123;&#123;list&#125;&#125;"</span> <span class="attr">key</span>=<span class="string">"index"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">item</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 插入&lt;script&gt;脚本部分所声明的child组件，同时传入item --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span> <span class="attr">:item</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repeat</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>computed计算属性，只要是组件中有任何数据发生了改变，那么所有计算属性就都会被重新计算，代码中可通过<code>this.计算属性名</code>来引用，模板中也可通过<code></code>来绑定数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;</span><br><span class="line">  a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算属性aPlus，在脚本中可通过this.aPlus来引用，在模板中可通过&#123;&#123; aPlus &#125;&#125;来插值</span></span><br><span class="line">computed = &#123;</span><br><span class="line">  aPlus () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>watcher监听器， 通过监听器<code>watcher</code>能够监听到任何属性的更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;</span><br><span class="line">  num: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听器函数名必须跟需要被监听的data对象中的属性num同名，</span></span><br><span class="line"><span class="comment">// 其参数中的newValue为属性改变后的新值，oldValue为改变前的旧值</span></span><br><span class="line">watch = &#123;</span><br><span class="line">  num (newValue, oldValue) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`num value: <span class="subst">$&#123;oldValue&#125;</span> -&gt; <span class="subst">$&#123;newValue&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数据绑定使用:号比如，不使用冒号是绑定字符串常量，sync不加，父组件这个变量变化就不会影响子组件，加了sync，同时，写了twoWay: true时就是双向绑定，即同一个属性（props）的变化，父修改了影响子，子修改了影响父</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:title</span>=<span class="string">"parentTitle"</span> <span class="attr">:syncTitle.sync</span>=<span class="string">"parentTitle"</span> <span class="attr">:twoWayTitle</span>=<span class="string">"parentTitle"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">props = &#123;</span><br><span class="line">    <span class="comment">// 静态传值</span></span><br><span class="line">    title: <span class="built_in">String</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父向子单向动态传值</span></span><br><span class="line">    syncTitle: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="string">'null'</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="comment">//这里即twoWay</span></span><br><span class="line">    twoWayTitle: &#123;</span><br><span class="line">        type: <span class="built_in">Number</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="string">'nothing'</span>,</span><br><span class="line">        twoWay: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>通信</p><p>父组件发起的：$broadcast（特性：所有子组件都会收到此广播事件，顺序由上至下，广度优先）</p><p>子组件发起的：$emit（特性：事件发起组件的所有祖先组件会依次接收到事件,顺序由下至上)</p><p>组件间发起的：$invoke (特性：一个页面或组件对另一个组件中的方法的直接调用)</p><p>$invoke示例(这里能否用到alias路径，大家可以试试)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$invoke(<span class="string">'./../ComB/ComG'</span>, <span class="string">'someMethod'</span>, <span class="string">'someArgs'</span>);</span><br></pre></td></tr></table></figure><p>回调均在events对象里面写</p></li><li><p>wxs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  text: &apos;This is from wxs&apos;,</span><br><span class="line">  filter: function (num) &#123;</span><br><span class="line">    return num.toFixed(2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// index.wpy</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;text&gt;&#123;&#123;m1.text&#125;&#125;&lt;/text&gt;</span><br><span class="line">  &lt;text&gt;&#123;&#123;m1.filter(num)&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import wepy from &apos;wepy&apos;;</span><br><span class="line">  import mywxs from &apos;../wxs/mywxs.wxs&apos;;</span><br><span class="line"></span><br><span class="line">  export default class Index extends wepy.page &#123;</span><br><span class="line"></span><br><span class="line">    data = &#123;</span><br><span class="line">      num: 10</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    wxs = &#123;</span><br><span class="line">      m1: mywxs</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>​</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;事件bindtap=”click”替换为@tap=”click”,防止冒泡@tap.stop,防止捕获@tap.capture.stop，如果是@someEvent.user=”somefunction”，这种通过this.$emit(‘someEvent
      
    
    </summary>
    
    
      <category term="wepy" scheme="http://yoursite.com/tags/wepy/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序api之setEnableDebug说明</title>
    <link href="http://yoursite.com/2018/03/04/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8Fapi%E4%B9%8BsetEnableDebug%E8%AF%B4%E6%98%8E/"/>
    <id>http://yoursite.com/2018/03/04/微信小程序api之setEnableDebug说明/</id>
    <published>2018-03-04T07:20:01.000Z</published>
    <updated>2018-03-04T07:29:09.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.js</span></span><br><span class="line">onLaunch() &#123;</span><br><span class="line">  <span class="comment">//开启调试</span></span><br><span class="line">  wx.setEnableDebug(&#123;</span><br><span class="line">    enableDebug: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><ul><li>这个接口相当于是用代码来在预览时开启调试，预览后打开小程序后会提示“重新打开小程序后生效”，点击确定后，在微信-发现-小程序中打开小程序，此时右下角会出现一个绿色可拖动的vConsole，可以显示调试信息</li><li>另一种非代码开启方式是点击小程序右上角的胶囊中三个点符号，在这里点击打开调试，会和上面讲的一样，出现同样的过程</li><li>如果设置enableDebug为false，会同样出现上述过程的逆过程，是一样的道理</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用方法&quot;&gt;&lt;a href=&quot;#使用方法&quot; class=&quot;headerlink&quot; title=&quot;使用方法&quot;&gt;&lt;/a&gt;使用方法&lt;/h1&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter
      
    
    </summary>
    
    
      <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程入门</title>
    <link href="http://yoursite.com/2018/02/28/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/02/28/函数式编程入门/</id>
    <published>2018-02-28T14:02:09.000Z</published>
    <updated>2018-03-04T05:24:43.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h1><p>函数式编程，个人理解是在编写纯函数。</p><p>据印度Anto Aravinth的解释的函数式编程是一种范式，我们能依靠这种范式创建仅依赖输入就可以完成自身逻辑的函数。</p><p>而这种函数就是我所理解的纯函数。</p><h2 id="纯函数特点"><a href="#纯函数特点" class="headerlink" title="纯函数特点"></a>纯函数特点</h2><ul><li>同样的输入，输出一定相同</li><li>函数不会改变任何外部环境的变量</li></ul><h2 id="函数式编程的引用透明性"><a href="#函数式编程的引用透明性" class="headerlink" title="函数式编程的引用透明性"></a>函数式编程的引用透明性</h2><blockquote><p>即所有函数对于相同输入都返回相同的值，那么据此产生了一个术语，叫替换模型，即把一个函数的调用用它的返回值替换，这将带来可以缓存的代码，当函数调用以后，我们将它的返回值存在内存里（比如用一个对象的属性存起来），下次使用就直接取对象这个属性映射的值。</p></blockquote><h2 id="并发优势"><a href="#并发优势" class="headerlink" title="并发优势"></a>并发优势</h2><ul><li>在并发层面上，由于函数不会对外部环境变量进行修改，只依赖传入的参数，所以，并发执行两个或多个一样的函数时相互之间不会受到影响</li></ul><h1 id="抽象与高阶函数"><a href="#抽象与高阶函数" class="headerlink" title="抽象与高阶函数"></a>抽象与高阶函数</h1><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><ul><li>个人总结维基百科的表述，抽象即是一种管理复杂度的方法，把复杂度限定到你能处理的范围。这个范围层面的确定即是一种抽象。</li><li>比如高级程序语言就是一种抽象，它的底层是复杂的汇编语言以及机器语言，然而你把它抽象出来进行问题的处理，而不考虑底层复杂的调用和实现</li><li>抽象使我们关注预定的目标而不去考虑底层的细节实现</li></ul><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><ul><li>高阶函数就是接受函数作为参数并且/或者返回函数作为输出的函数</li><li>经常用到的比如map，forEach等</li></ul><h3 id="高阶函数的思维"><a href="#高阶函数的思维" class="headerlink" title="高阶函数的思维"></a>高阶函数的思维</h3><ul><li>高阶函数是一种声明式的抽象，声明式即研究“做什么”而不是“如何做”，而抽象使问题关注的地方更加单一，简单化</li><li>比如forEach函数抽象出了遍历数组这个过程，我们不用去关心如何去做遍历，而是专注于对每次遍历的结果的操作</li></ul><h1 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h1><h2 id="一元函数与多元函数"><a href="#一元函数与多元函数" class="headerlink" title="一元函数与多元函数"></a>一元函数与多元函数</h2><ul><li>只接受一个参数的函数叫一元函数，可以以此类推，几元函数就是接受几个参数的函数</li></ul><h2 id="变参函数"><a href="#变参函数" class="headerlink" title="变参函数"></a>变参函数</h2><ul><li>函数接受的参数不确定的函数叫做变参函数（比如使用arguments）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 变参函数</span><br><span class="line"> */</span><br><span class="line">function vary(...args) &#123;</span><br><span class="line">  console.log(args)</span><br><span class="line">  //do something to args</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="柯里化思想"><a href="#柯里化思想" class="headerlink" title="柯里化思想"></a>柯里化思想</h2><ul><li>所谓柯里化就是把多参函数转化为嵌套的单参函数</li></ul><h2 id="currying的一种实现"><a href="#currying的一种实现" class="headerlink" title="currying的一种实现"></a>currying的一种实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将多参函数转换为单参函数的一种实现</span></span><br><span class="line"><span class="comment"> * @params fn 需要转化的多参函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//异常处理</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fn is not a function'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//转换处理</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curryInner</span>(<span class="params">...args</span>) =&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//当传入函数的参数数目大于返回curryInner的参数长度时</span></span><br><span class="line">  <span class="keyword">if</span> (fn.length &gt; args.length)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> curryInner.apply(<span class="literal">null</span>, args.concat([].slice.call(<span class="built_in">arguments</span>)))</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析举例"><a href="#分析举例" class="headerlink" title="分析举例"></a>分析举例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试函数作为实参传递</span></span><br><span class="line"><span class="comment"> * @params x, y, z</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curriedFn = curry(foo);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此时curriedFn为 </span></span><br><span class="line"><span class="comment"> * function curryInner(...args) =&gt; &#123;  </span></span><br><span class="line"><span class="comment"> * if (fn.length &gt; args.length)&#123;</span></span><br><span class="line"><span class="comment"> *      return function() &#123;</span></span><br><span class="line"><span class="comment"> *       return curryInner.apply(null, args.concat([].slice.call(arguments)))</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> *   return fn.apply(null, args)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用并传入实参1, 2 ,3</span></span><br><span class="line">curriedFn(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><ul><li><p>当执行到curriedFn(1)时，因为args.length为1，fn.length为3所以进入if块将args的参数连接，此时args.length为2</p></li><li><p>上一步返回的还是curryInner函数，再执行curriedFn(1)(2),此时由于args.length为2还是小于3，再重复上述步骤执行curriedFn(1)(2)(3)</p></li><li><p>此时args.length为3，if条件不满足，执行fn.apply(null, args),即相当于执行了foo(1,2,3)</p></li></ul><h1 id="文献参考："><a href="#文献参考：" class="headerlink" title="文献参考："></a>文献参考：</h1><p>《JavaScript ES6 函数式编程入门经典》                            【印】Anto Aravinth 著  梁宵 译</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是函数式编程&quot;&gt;&lt;a href=&quot;#什么是函数式编程&quot; class=&quot;headerlink&quot; title=&quot;什么是函数式编程&quot;&gt;&lt;/a&gt;什么是函数式编程&lt;/h1&gt;&lt;p&gt;函数式编程，个人理解是在编写纯函数。&lt;/p&gt;
&lt;p&gt;据印度Anto Aravinth的解释的
      
    
    </summary>
    
    
      <category term="心得体会" scheme="http://yoursite.com/tags/%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>mark</title>
    <link href="http://yoursite.com/2018/02/22/mark/"/>
    <id>http://yoursite.com/2018/02/22/mark/</id>
    <published>2018-02-22T10:57:35.000Z</published>
    <updated>2018-02-22T11:04:42.194Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  test(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">SomeComponent</span> <span class="attr">callback</span>=<span class="string">&#123;(a,</span> <span class="attr">b</span>) =&gt;</span> &#123;this.test(a, b)&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">test</span>) </span>&#123;</span><br><span class="line">  test(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;SomeComponent callback=&#123;::this.test&#125; /&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
    
      <category term="记录" scheme="http://yoursite.com/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>html5的data-*</title>
    <link href="http://yoursite.com/2018/02/12/html5%E7%9A%84data/"/>
    <id>http://yoursite.com/2018/02/12/html5的data/</id>
    <published>2018-02-12T10:51:30.000Z</published>
    <updated>2018-02-12T11:06:00.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>看公司的表单组件，发现一个data-name属性，这个在最早做react的todo时，遇到过，因为获取不到直接定义的属性，还写过一篇肤浅的博客。其实这个并不是react里面的内容，而是html5里面的</p><h1 id="data-用法"><a href="#data-用法" class="headerlink" title="data-*用法"></a>data-*用法</h1><p>目前我没有参考文档，所以不知道它为什么会出现，但是我知道怎么用，在什么场景用，直接讲自己理解的用法。</p><p>获取这个属性，可以利用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">domNode.getAttribute(<span class="string">'data-foo'</span>)</span><br></pre></td></tr></table></figure><p>这个其中一个应用场景就是你在react中获取节点后，想获取这个data-属性里面的值</p><p>还可以在事件对象的当前对象下的dataset属性中获取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.currentTarget.dataset.foo;</span><br></pre></td></tr></table></figure><p>这个让我想到了小程序，它内部实现也估计用了这个。</p><h1 id="延伸题外话"><a href="#延伸题外话" class="headerlink" title="延伸题外话"></a>延伸题外话</h1><p>html5很重要，很多东西经常用到，我们应该怎么学习html5，我的体会是从html5名字去搜书名得到的书是不行的。但是有一本书，我最近翻了翻，发现里面有很多html5的内容，那就是大家都知道的《JavaScript高级程序设计》，很厚，一天读10页，也要很久读完，推荐大家如果忙的话，把它当字典查，当然最好是读一遍。</p><p>我之前项目搜data-name没搜到，后来看了mdn以后，我说不可能搜不到，肯定是之前没搜好，果然就是我的想法，搜到了，也是上述用法用的。</p><h1 id="REACT16以后"><a href="#REACT16以后" class="headerlink" title="REACT16以后"></a>REACT16以后</h1><p>可以不用data-*，不带data-的属性也会渲染到原生dom节点上了</p><p>更多内容待大家一起探讨，下次见</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h1&gt;&lt;p&gt;看公司的表单组件，发现一个data-name属性，这个在最早做react的todo时，遇到过，因为获取不到直接定义的属性，还写过一篇肤浅的博
      
    
    </summary>
    
    
      <category term="html5" scheme="http://yoursite.com/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>聊聊webpack</title>
    <link href="http://yoursite.com/2018/02/10/%E8%81%8A%E8%81%8Awebpack/"/>
    <id>http://yoursite.com/2018/02/10/聊聊webpack/</id>
    <published>2018-02-10T10:04:19.000Z</published>
    <updated>2018-02-10T10:24:29.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原创申明"><a href="#原创申明" class="headerlink" title="原创申明"></a>原创申明</h1><ul><li>该空间内所有博客所有内容均为原创，由于是个人的理解，可能有所勘误，敬请指正</li></ul><h1 id="webpack个人对它的介绍"><a href="#webpack个人对它的介绍" class="headerlink" title="webpack个人对它的介绍"></a>webpack个人对它的介绍</h1><ul><li>webpack会从一个文件或者多个文件开始，它里面的依赖的模块，会被以webpack的方式优雅的合成一个或多个bundle文件，这里是对js的构建，那么这时，你可以把它引用到html的script标签中。但是一般不是你手动引入，webpack可以帮你做到，用到的就是它的插件，包括css也是类似的道理，会被引到head的link标签里。</li><li>上述过程生成的东西会产生一个文件夹，这个文件夹你可以指定，这个文件夹包含了一套的前端所需要的东西，是什么呢？那就是现代浏览器可以执行的html，css，js。</li><li>为什么要加上现代浏览器可以执行的，因为这很重要，而且也因为我们写的代码都是浏览器不支持的，我们把这个文件夹的内容放到服务器上部署，就有一个前端的内容了。</li><li>为什么要写浏览器不支持的代码？其中很重要的一点，是程序员里面很常见的词汇，那就是优雅。对，这些代码很优雅，有很多语法糖。什么是语法糖，我个人理解，是通过约定把本来需要一大堆代码实现的东西变成简单的写法。这就很优雅，那么优雅是什么，优雅就是开发效率，与开发时的快感的增加。</li><li>webpack有很多东西在官网上浅尝则止，并没有说的很深入，如果想要深入可以阅读《深入浅出webpack》，我也在读，不过我经过搭了一个react react-router v4 按需加载的项目之后在读，体会更佳，欢迎加入。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原创申明&quot;&gt;&lt;a href=&quot;#原创申明&quot; class=&quot;headerlink&quot; title=&quot;原创申明&quot;&gt;&lt;/a&gt;原创申明&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;该空间内所有博客所有内容均为原创，由于是个人的理解，可能有所勘误，敬请指正&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=
      
    
    </summary>
    
    
      <category term="心得体会" scheme="http://yoursite.com/tags/%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>日期+学习到的知识点</title>
    <link href="http://yoursite.com/2018/01/30/%E6%97%A5%E6%9C%9F-%E5%AD%A6%E4%B9%A0%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2018/01/30/日期-学习到的知识点/</id>
    <published>2018-01-30T13:26:20.000Z</published>
    <updated>2018-02-21T09:18:07.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2018-1-30"><a href="#2018-1-30" class="headerlink" title="2018-1-30"></a>2018-1-30</h1><ul><li>css filter: drop-shadow()</li><li>sass draken()</li><li>sass placeholder</li><li>sass @include</li><li>sass @content</li><li>redux mapDispatchToProps dispatched function(bindActionCreator)</li><li>react-router onEnter hook(20%)</li><li>react-router IndexRoute IndexRedirect</li><li>高阶函数例子及定义</li></ul><h1 id="2018-2-13"><a href="#2018-2-13" class="headerlink" title="2018-2-13"></a>2018-2-13</h1><ul><li>understand es7 function bind syntax in react</li><li>review this in ecmascript</li></ul><h1 id="2018-2-17"><a href="#2018-2-17" class="headerlink" title="2018-2-17"></a>2018-2-17</h1><ul><li>currentTarget &lt;- represent registered element and equal to this in event handler</li><li>target &lt;- actual and real target in event</li><li>understand function parameters transfer by value</li></ul><h1 id="2018-2-21"><a href="#2018-2-21" class="headerlink" title="2018-2-21"></a>2018-2-21</h1><ul><li>scope chain and excution context environment</li><li>reference counting strategy of garbage collection </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2018-1-30&quot;&gt;&lt;a href=&quot;#2018-1-30&quot; class=&quot;headerlink&quot; title=&quot;2018-1-30&quot;&gt;&lt;/a&gt;2018-1-30&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;css filter: drop-shadow()&lt;/li&gt;
&lt;li&gt;s
      
    
    </summary>
    
    
      <category term="学习记录" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>陪自己走过白天黑夜</title>
    <link href="http://yoursite.com/2018/01/25/%E9%99%AA%E8%87%AA%E5%B7%B1%E8%B5%B0%E8%BF%87%E7%99%BD%E5%A4%A9%E9%BB%91%E5%A4%9C/"/>
    <id>http://yoursite.com/2018/01/25/陪自己走过白天黑夜/</id>
    <published>2018-01-25T05:13:15.000Z</published>
    <updated>2018-01-25T05:48:51.062Z</updated>
    
    <content type="html"><![CDATA[<p>cnode论坛好像是狼叔建的，一个很有趣的地方，一个卧虎藏龙的地方。</p><p>比如昨天，我在上面发现了一位我很欣赏的前辈，他叫邹业盛。起初并不认识他，我只是在cnode上面瞎逛，把一些有可能会用到帖子打开，寻找一点营养吸收一下，我在几篇可能出现干货的帖子下发现了一个人，他把问题分析得极其透彻，就是用自己的话说出来的那种，而且一看就是踩过了那些坑并有很深体会的人。我顿时在github中寻找他，还真给我找到，于是进入到他的博客里面，文章都很朴实，满满干货，还带个人体会，读完收获不小。今天仔细看他的title，原来是阿里的。</p><p>记得狼叔曾经开个一个玩笑，所有的前端程序员的归宿不是阿里就是在去阿里的路上。确实从侧面也反映了一个问题，就是阿里的员工真的很优秀。我目前网上见到的阿里的人都是很全面的人。强到可怕，普通公司的人跟阿里的一比，差距就是十万八千里，不过也夸张了一点，只是想说，他们很强。</p><p>昨天我问同事，我说你的职业规划是怎样的，他说估计以后是往管理或者创业发展。我又问其他同事，答案也差不多。我总结一下，他们的看法是35岁要做成管理或者架构师。对我来说还有10年，10年是很长的。如果这10年，每日精进，他们的想法都是可以实现的。也有很多这样的人，他们只花了几年。</p><p>链家的鸟哥说要脱离自己的舒适区，上面说的其实就要做到鸟叔说的那样才好实现。如果停留在自己的舒适区，就是网上流行的1年经验重复3年。我想的是，劳逸结合，带点紧迫感的顺其自然，这样比较适合我这种人，有松有紧。</p><p>以前迷吉他指弹的时候，老是看日本押尾桑的视频，他说学习的时候跟吉他老师交流，与同学交流进步更快，也更有乐趣。这里有两个关键词，进步和乐趣，这两点相辅相成。虽然已经工作了，我也类似的报了一个班，接触了一些朋友和老师，老师都是阿里或者一些知名公司的。于是就有了一个氛围，是在线的。我一般是看录播，因为平时都在加班。看过一遍，老师说的话对我很有指导作用。了解一些骚操作。偶尔会在群里问一下node的问题，除了node问题的基本不会问。问也是问一些通用的解决方案，也就是套路。当然我还问过狼叔，狼叔人很好的，回答也很赞。所以我学习有很多途径，一方面自己看书看博客文章，二方面工作积累用博客记录，三方面各种我自己营造的氛围，比如知识星球，微信群，qq群，报的班的资料，四方面向高手请教，论坛提问。</p><p>我的博客技术为主，辅助一些自己个人随笔，蝼蚁之词，见笑了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;cnode论坛好像是狼叔建的，一个很有趣的地方，一个卧虎藏龙的地方。&lt;/p&gt;
&lt;p&gt;比如昨天，我在上面发现了一位我很欣赏的前辈，他叫邹业盛。起初并不认识他，我只是在cnode上面瞎逛，把一些有可能会用到帖子打开，寻找一点营养吸收一下，我在几篇可能出现干货的帖子下发现了一个人
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>解决小程序音频自定义组件不同时播放问题</title>
    <link href="http://yoursite.com/2018/01/25/%E8%A7%A3%E5%86%B3%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%9F%B3%E9%A2%91%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E4%B8%8D%E5%90%8C%E6%97%B6%E6%92%AD%E6%94%BE%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/01/25/解决小程序音频自定义组件不同时播放问题/</id>
    <published>2018-01-24T16:22:07.000Z</published>
    <updated>2018-03-11T08:23:05.004Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>首先是一个播放的气泡，点击播放src音频，但是是一组列表，有许多这样的气泡，点其中一个播放后，再点其他的，前一个要停止播放。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这种其实是很好实现的，如果是直接写的话。但是现在用上了小程序的自定义组件，每个组件都是独立的没有联系，唯一的联系是父组件，这个时候，我们该怎么办呢。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>由于涉及保密协议，就不上代码，说说思路。</p><p>思路：</p><ol><li>用广播，如果该组件播放时，就发出一个广播，让其他组件关闭播放。</li></ol><p>这里知识用到观察者模式（订阅与发布），具体怎么实现，有很多方式，本项目中的实现是我的师父写的，然而他写的有个地方有问题，他用了Promise处理监听的回调，然而Promise resolve以后，它的生命就到此为止了（个人目前的理解是这样的，如有勘误，请务必指出），所以只能执行一次回调，而不能多次监听，触发回调。我把这里改了，实现了一次监听，有触发随时执行。</p><ol><li>关键问题，我怎么样只广播非当前播放的气泡呢。设一个属性，每次给一个变化的值进去，利用observer确定是当前组件，当前组件执行一个逻辑，这个逻辑就是避免被广播到</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>程序出不来，大部分是代码原因，继续搞，继续搞就能看到光明。</p><p>我的每篇文章都不长，但都可以说明一个问题，欢迎阅读。</p><p>-————–update分割线 —————–</p><p>最佳实践是这样的：</p><p><a href="https://choicelin.github.io/2018/01/09/%E5%89%8D%E7%AB%AF%E5%B7%A5%E4%BD%9C%E9%81%87%E5%88%B0%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/" target="_blank" rel="noopener">前端工作遇到的小知识点</a>第14点，最好放在父组件中控制，上面操作太骚，而且后期处理起来不易维护</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h1&gt;&lt;p&gt;首先是一个播放的气泡，点击播放src音频，但是是一组列表，有许多这样的气泡，点其中一个播放后，再点其他的，前一个要停止播放。&lt;/p&gt;
&lt;h1
      
    
    </summary>
    
    
      <category term="工作经验" scheme="http://yoursite.com/tags/%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>带着如何开放不使用jwt路由而阅读koa-jwt源码引出对koa-unless的阅读</title>
    <link href="http://yoursite.com/2018/01/21/%E5%B8%A6%E7%9D%80%E5%A6%82%E4%BD%95%E5%BC%80%E6%94%BE%E4%B8%8D%E4%BD%BF%E7%94%A8jwt%E8%B7%AF%E7%94%B1%E8%80%8C%E9%98%85%E8%AF%BBkoa-jwt%E6%BA%90%E7%A0%81%E5%BC%95%E5%87%BA%E5%AF%B9koa-unless%E7%9A%84%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2018/01/21/带着如何开放不使用jwt路由而阅读koa-jwt源码引出对koa-unless的阅读/</id>
    <published>2018-01-21T05:24:01.000Z</published>
    <updated>2018-01-21T06:08:37.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h1><p>想往项目里面加入401状态，而考虑使用比较公认的jwt技术，遇到一个问题，就是如何开放一些不需要token的路由？</p><h1 id="尝试获取资料"><a href="#尝试获取资料" class="headerlink" title="尝试获取资料"></a>尝试获取资料</h1><p>于是寻找github上面一些使用jwt验证的项目阅读其中的源码，然而发现都不是自己原生使用jsonwebtoken而是用的express-jwt和koa-jwt，而这两个库都有我尝试解决的问题的解决方案，于是我找到koa-jwt的源码，发现里面使用了koa-unless库，这个库是干嘛的呢，实际是让你指定的路由跳过当前的中间件，那么看看源码。</p><h1 id="阅读koa-unless源码"><a href="#阅读koa-unless源码" class="headerlink" title="阅读koa-unless源码"></a>阅读koa-unless源码</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Creates a wrapper middleware that verifies if the original middleware should be skipped. */</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> originalMiddleware = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If a custom function was passed directly, creates a new object literal that holds it as a property called custom.</span></span><br><span class="line">  <span class="keyword">var</span> opts = <span class="keyword">typeof</span> options === <span class="string">'function'</span> ? &#123; <span class="attr">custom</span>: options &#125; : options;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns the middleware that wraps the original one.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> *(<span class="params">next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> requestedUrl = url.parse((opts.useOriginalUrl ? <span class="keyword">this</span>.originalUrl : <span class="keyword">this</span>.url) || <span class="string">''</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// any match means 'skip original middleware'</span></span><br><span class="line">    <span class="keyword">if</span> (matchesCustom(<span class="keyword">this</span>, opts) || matchesPath(requestedUrl, opts) ||</span><br><span class="line">        matchesExtension(requestedUrl, opts) || matchesMethod(<span class="keyword">this</span>.method, opts)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">yield</span> *next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> *originalMiddleware.call(<span class="keyword">this</span>, next);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关键地方</p><ol><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> originalMiddleware = <span class="keyword">this</span>;</span><br><span class="line"><span class="comment">//这里获取当前要跳过的中间件实例</span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (matchesCustom(<span class="keyword">this</span>, opts) || matchesPath(requestedUrl, opts) ||</span><br><span class="line">        matchesExtension(requestedUrl, opts) || matchesMethod(<span class="keyword">this</span>.method, opts)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">yield</span> *next; <span class="comment">//这里判断参数匹配的话，就把控制权转移下个中间件，从而跳过该中间件</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> *originalMiddleware.call(<span class="keyword">this</span>, next);</span><br><span class="line"><span class="comment">//这一句结合上面一句来看就是参数不匹配就执行当前中间件</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的思路是不执行jwt的验证的中间件，思路其实也很直接，那我就愉快的借用一下罗。~_~!</p><h1 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h1><p>国外源码注释真的很清晰，其实在工作中应该也效仿。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题引入&quot;&gt;&lt;a href=&quot;#问题引入&quot; class=&quot;headerlink&quot; title=&quot;问题引入&quot;&gt;&lt;/a&gt;问题引入&lt;/h1&gt;&lt;p&gt;想往项目里面加入401状态，而考虑使用比较公认的jwt技术，遇到一个问题，就是如何开放一些不需要token的路由？&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>node流程控制之串行</title>
    <link href="http://yoursite.com/2018/01/18/node%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B9%8B%E4%B8%B2%E8%A1%8C/"/>
    <id>http://yoursite.com/2018/01/18/node流程控制之串行/</id>
    <published>2018-01-18T10:22:28.000Z</published>
    <updated>2018-01-18T10:33:02.050Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function process1() &#123;</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">   var process1Result = 1;</span><br><span class="line">   next(null, process1Result)</span><br><span class="line">  &#125;,10)</span><br><span class="line">&#125;</span><br><span class="line">function process2(data) &#123;</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">  if (data === 1) var process2Result = 2;</span><br><span class="line">    next(null, process2Result)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function process3(data) &#123;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var taskList = [</span><br><span class="line">  process1,</span><br><span class="line">  process2,</span><br><span class="line">  process3</span><br><span class="line">]</span><br><span class="line">next(err, result) &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line">  </span><br><span class="line">  var current = taskList.shift();</span><br><span class="line">  </span><br><span class="line">  current &amp;&amp; current(result);</span><br><span class="line">&#125;</span><br><span class="line">next();</span><br></pre></td></tr></table></figure><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><ul><li><p>在node中让一组异步操作顺序执行的套路叫做流程控制，而这其中又分为串行流程和并行流程</p><h2 id="串行流程"><a href="#串行流程" class="headerlink" title="串行流程"></a>串行流程</h2><ul><li>所谓串行流程，即一个接着一个做的流程叫做串行流程，上述代码即一个串行流程的实现。</li><li>首先有三个操作，顺序依次为process1，process2，process3，</li><li>整个过程的核心是这个next函数，跟node一些框架中交出控制权的next名字是一样的</li><li>思路就是按照索引的顺序执行函数，函数中异步调用的返回值，作为下一个next中执行的函数的参数，保证了数据不会丢失。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>Node编程基础</title>
    <link href="http://yoursite.com/2018/01/11/Node%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/01/11/Node编程基础/</id>
    <published>2018-01-11T05:59:29.000Z</published>
    <updated>2018-01-11T06:00:40.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node编程基础"><a href="#Node编程基础" class="headerlink" title="Node编程基础"></a>Node编程基础</h1><h2 id="如何组织代码"><a href="#如何组织代码" class="headerlink" title="如何组织代码"></a>如何组织代码</h2><blockquote><p>模块是Node让代码易于重用的一种组织和包装方式</p></blockquote><ul><li>传统方式按逻辑把单个文件分为多个文件，但这些文件互相引用的同时会产生全局变量污染的问题</li><li>Node模块打包代码是为了重用，但它们不会改变全局作用域</li><li>Node模块允许你从被引入文件中选择要你暴露给程序的函数和变量，如果模块返回的函数和变量不止一个，可以把它们作为exports对象的属性，否则就使用module.exports</li></ul><h3 id="如何创建模块"><a href="#如何创建模块" class="headerlink" title="如何创建模块"></a>如何创建模块</h3><ul><li>模块既可能是一个文件，也可能是包含一个或多个文件的目录。如果模块是一个目录，Node通常会在这个目录下找一个叫index.js的文件作为模块的入口</li><li>使用模块要用到require函数，require是Node中少数几个同步I/O操作之一</li></ul><h4 id="用node-modules重用模块"><a href="#用node-modules重用模块" class="headerlink" title="用node_modules重用模块"></a>用node_modules重用模块</h4><ul><li><p>要求模块在文件系统中使用相对路径存放，对于组织程序特定的代码很有帮助，但是与他人共享代码却用处不大。Node的node_modules机制可以不必知道模块在文件系统中的具体位置。</p></li><li><p>node_modules的搜寻机制如下：</p><p>1.开始在文件同一目录下寻找；</p><p>2.没有找到，就在当前目录node_modules下找</p><p>3.没有找到，进入父目录，再找当前目录node_modules中有没有，重复3；</p><p>4.没有找到，找环境变量NODE_PATH指定目录中是否存在；</p><p>5没有找到，异常。</p></li></ul><h2 id="异步编程技术"><a href="#异步编程技术" class="headerlink" title="异步编程技术"></a>异步编程技术</h2><ul><li><p>事件发生会触发响应逻辑。</p></li><li><p>在Node事件里流行两种响应逻辑的管理方式：</p><ol><li><p>回调</p><blockquote><p>回调通常用来定义一次性响应逻辑。比如数据库查询，可以指定一个回调函数来确定如何处理查询结果。这个回调函数可能会显示数据数据库查询结果，根据这些结果做些计算，或者以查询结果为参数执行另一个回调函数</p></blockquote></li><li><p>事件监听</p><blockquote><p>事件监听器，本质上也是一个回调，不同的是，它跟一个事件相关联。在Node中，当有HTTP请求过来时，此时服务器会产生一个事件，事件监听器就可以监听这个事件，并添加一些响应的逻辑。</p></blockquote></li></ol></li><li><p>一个Node HTTP服务器实例就是一个事件发射器</p></li><li><p>能够继承和添加事件发射及处理能力的类（EventEmitter）</p></li></ul><p>（未完待续）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Node编程基础&quot;&gt;&lt;a href=&quot;#Node编程基础&quot; class=&quot;headerlink&quot; title=&quot;Node编程基础&quot;&gt;&lt;/a&gt;Node编程基础&lt;/h1&gt;&lt;h2 id=&quot;如何组织代码&quot;&gt;&lt;a href=&quot;#如何组织代码&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>基本视觉格式化</title>
    <link href="http://yoursite.com/2018/01/11/%E5%9F%BA%E6%9C%AC%E8%A7%86%E8%A7%89%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    <id>http://yoursite.com/2018/01/11/基本视觉格式化/</id>
    <published>2018-01-11T05:48:33.000Z</published>
    <updated>2018-01-16T05:27:23.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本视觉格式化"><a href="#基本视觉格式化" class="headerlink" title="基本视觉格式化"></a>基本视觉格式化</h1><h2 id="基本框"><a href="#基本框" class="headerlink" title="基本框"></a>基本框</h2><ul><li>css假定每个元素都会生成一个或多个矩形框，这称为元素框。各元素框中心有一个内容区。这个内容区周围有可选的内边距，边框和外边距。</li></ul><h2 id="包含块（布局上下文）"><a href="#包含块（布局上下文）" class="headerlink" title="包含块（布局上下文）"></a>包含块（布局上下文）</h2><ul><li>每个元素都相对于其包含块摆放。正常流中的一个元素，其包含块由最近的块级祖先框、表单元格或行内块祖先框的内容边界构成。</li></ul><blockquote><p>正常流是指西方语言文本从左向右、从上向下显示。大多数元素都在正常流中，除了浮动或定位元素。</p></blockquote><h2 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h2><ul><li>一般一个基本框从左到右有这几个部分：<ol><li>左外边界</li><li>左外边距</li><li>左边框</li><li>左内边距</li><li>左内边界</li><li>内容区宽度</li><li>右内边界</li><li>右内边距</li><li>右边框</li><li>右外边距</li><li>右外边界</li></ol></li><li>一般地，一个元素的宽度（width）被定义为从左内边界到右内边界的距离，高度同理。高度和宽度属性都可以应用到元素。</li><li>不同的宽度、高度、内边距和外边距相结合，就可以确定文档的布局。</li></ul><h3 id="水平格式化"><a href="#水平格式化" class="headerlink" title="水平格式化"></a>水平格式化</h3><ul><li>区分width和可见元素框的宽度，width属性是不包含padding和margin的（例外的是使用了CSS3的box-sizing），而可见元素框宽度是包含了padding和margin的</li><li>有个规则，正常流中块级元素框的水平部分总和就等于父元素width。这一句话即所有子元素的width加上它们的左、右内边距，边框和外边距就是父元素的width。</li></ul><h4 id="水平属性"><a href="#水平属性" class="headerlink" title="水平属性"></a>水平属性</h4><ul><li>水平格式化有7大属性，从左至右，分别是：margin-left, border-left,padding-left,width,padding-right,border-right,margin-right。这7个属性的值加在一起必须是元素包含块的宽度，这往往是块元素的的父元素的width。</li><li>这7大属性只有其中3个可以设置为auto（width，margin-left,margin-right）</li></ul><h4 id="使用auto（不考虑3个值以外的属性）"><a href="#使用auto（不考虑3个值以外的属性）" class="headerlink" title="使用auto（不考虑3个值以外的属性）"></a>使用auto（不考虑3个值以外的属性）</h4><ol><li>3个auto（margin-left,width,margin-right均为auto），其中width会占满父元素width，而margin-left,margin-right为0</li><li>2个auto（比如margin-left,width为auto），这时设置auto的属性会为0，width会将父元素width的剩余空间占满</li><li>1个auto，如果设置3个值其中一个为auto，那么设置auto的属性会确定所需的长度，保证3个值加起来等于父元素的width</li><li>0个auto同时三者设置的和超过父元素width，则margin-right会为auto。</li></ol><p>（未完待续）</p><h4 id="负外边距"><a href="#负外边距" class="headerlink" title="负外边距"></a>负外边距</h4><ul><li>外边距可以为负</li><li>7个水平属性总和要等于父元素的width，严格的说这个总和不能比包含块更宽。所以当外边距为负时子元素的width会超过父元素width，达到一种超出的效果</li><li>只要所有属性都是大于或等于0的，元素就不会大于父元素的内容区</li></ul><h4 id="百分数"><a href="#百分数" class="headerlink" title="百分数"></a>百分数</h4><ul><li>值声明为长度还是百分数，并没有改变上述水平格式化规则</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本视觉格式化&quot;&gt;&lt;a href=&quot;#基本视觉格式化&quot; class=&quot;headerlink&quot; title=&quot;基本视觉格式化&quot;&gt;&lt;/a&gt;基本视觉格式化&lt;/h1&gt;&lt;h2 id=&quot;基本框&quot;&gt;&lt;a href=&quot;#基本框&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="css读书笔记" scheme="http://yoursite.com/tags/css%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>前端工作遇到的小知识点</title>
    <link href="http://yoursite.com/2018/01/09/%E5%89%8D%E7%AB%AF%E5%B7%A5%E4%BD%9C%E9%81%87%E5%88%B0%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2018/01/09/前端工作遇到的小知识点/</id>
    <published>2018-01-09T02:21:41.000Z</published>
    <updated>2018-03-08T08:34:10.597Z</updated>
    
    <content type="html"><![CDATA[<ol><li>顶部子元素的margin-top直接到父元素上，目前简单的处理方法将子元素margin-top变成父元素padding-top,感觉其他方式也可以解决比如改变BFC，需要补一下BFC，还不太熟</li><li>微信小程序中，纵向的高度一定不要px，否则到不同屏幕上差异很明显，横向如果写滑动的效果，计算的left值可以用px，因为获取到的屏幕的宽度是一个以px为单位的值，用px才不会出现位置上偏移的问题。</li><li>文本溢出无法实现时，使用height,line-height,overflow做</li><li>做列表勾选同步时，前端修改了数据勾选状态，如果请求后端同步时失败，应回滚前端勾选状态，这中列表数据自带勾选状态的做法，也是一种性能优化的经验</li><li>接口全局配置，如果有两套环境（生产和测试），在页面里用到相关接口url，必须通过配置文件来引用，而不是直接写，如果有不同，就切分字符串，不然你绝对会不停的改来改去。</li><li>原生小程序，setData方法绝对不能set一个undefined值，否则真机会报一个null的错误，同时定位这种错误的方法是打console看这个null的log在console的前面还是后面来定位，巨坑哦</li><li>原生小程序组件在一个页面多次使用，并且要实现使用父组件的data作为组件的property，即在子组件要改变父组件data，来引起子组件properties变化，从而引起视图变化，达到一中父子组件通信的目的，可以充分使用triggerEvent方法，并且在触发时传入type字符串，以实现多态。</li><li>遇到一个问题，小程序在audio播放toggle时flag不生效，起初以为是flag的原因，结果是因为每次都生成了新的播放实例，在新的播放实例上调stop是无效的</li><li>calc运算符号是要空格的，要不然calc出不来;</li><li>小程序wxs出错弹层类型拿数据后会在真机直接奔溃，如果你确定template等传值都是对的，那么这个时候你需要看看wxs传入的值是否正确，这在控制台是不会报错的</li><li>列表点击弹出列表选取列表项逻辑应该是，点第一个列表时记录该列表项id，然后在第二个列表点确定时设置下一个id，并跑接口，取消则清空两个id；</li><li>生产环境小程序在打开时有两种情况，第一种是打开后到首页，这种无疑会触发onLaunch；还有一种是打开后进入其它页面然后关闭，再马上打开，这时还在之前显示的页面，这时并没有触发onLaunch;</li><li>小程序中innerAudioContext使用必须开启铃声状态才有声音哦,同时oncanplay可能会有问题</li><li>防止同时播放问题，保证运行的父组件中只有一个播放context，同时再播放前将其他全部标志设置为false</li><li>cpm config set registry <a href="http://fjdsklajf.com" target="_blank" rel="noopener">http://fjdsklajf.com</a>;</li><li>scss _前缀是用在一个文件不需要编译时，引入时可以去掉下划线</li></ol><p>此文长期更新，遇到什么就写什么，mark</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;顶部子元素的margin-top直接到父元素上，目前简单的处理方法将子元素margin-top变成父元素padding-top,感觉其他方式也可以解决比如改变BFC，需要补一下BFC，还不太熟&lt;/li&gt;
&lt;li&gt;微信小程序中，纵向的高度一定不要px，否则到不同屏
      
    
    </summary>
    
    
      <category term="工作" scheme="http://yoursite.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>html标签</title>
    <link href="http://yoursite.com/2018/01/05/html%E6%A0%87%E7%AD%BE/"/>
    <id>http://yoursite.com/2018/01/05/html标签/</id>
    <published>2018-01-05T05:24:08.000Z</published>
    <updated>2018-01-05T05:40:43.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="htmls所有标签"><a href="#htmls所有标签" class="headerlink" title="htmls所有标签"></a>htmls所有标签</h1><ul><li>a</li><li>abbr</li><li>acronym</li><li>address</li><li>applet</li><li>area</li><li>article</li><li>aside</li><li>audio</li><li>b</li><li>base</li><li>basefont</li><li>bdi</li><li>bdo</li><li>bgsound</li><li>big</li><li>blink</li><li>blockquote</li><li>body</li><li>br</li><li>button</li><li>canvas</li><li>caption</li><li>center</li><li>cite</li><li>code</li><li>col</li><li>colgroup</li><li>command</li><li>content</li><li>data</li><li>datalist</li><li>dd</li><li>del</li><li>details</li><li>dfn</li><li>dialog</li><li>dir</li><li>div</li><li>dl</li><li>dt</li><li>element</li><li>em</li><li>embed</li><li>fieldset</li><li>figcaption</li><li>figure</li><li>font</li><li>footer</li><li>form</li><li>frame</li><li>frameset</li><li>h1~h6</li><li>head</li><li>header</li><li>hgroup</li><li>hr</li><li>html</li><li>i</li><li>iframe</li><li>image(请勿使用，从未实现)</li><li>img</li><li>input</li><li>ins</li><li>isindex</li><li>kbd</li><li>keygen</li><li>label</li><li>legend</li><li>li</li><li>link</li><li>listing</li><li>main</li><li>map</li><li>mark</li><li>marquee</li><li>menu</li><li>menuitem</li><li>meta</li><li>meter</li><li>multicol</li><li>nav</li><li>nextid</li><li>nobr</li><li>noembed</li><li>noframes</li><li>noscript</li><li>object</li><li>ol</li><li>optgroup</li><li>option</li><li>output</li><li>p</li><li>param</li><li>picture</li><li>plaintext</li><li>pre</li><li>progress</li><li>q</li><li>rp</li><li>rt</li><li>rtc</li><li>ruby</li><li>s</li><li>samp</li><li>script</li><li>section</li><li>select</li><li>shadow</li><li>slot</li><li>small</li><li>Source</li><li>spacer</li><li>span</li><li>strike</li><li>strong</li><li>style</li><li>sub</li><li>summary</li><li>sup</li><li>table</li><li>tbody</li><li>td</li><li>template</li><li>textarea</li><li>tfoot</li><li>th</li><li>thead</li><li>time</li><li>title</li><li>tr</li><li>track</li><li>tt</li><li>u</li><li>ul</li><li>var</li><li>video</li><li>wbr</li><li>xmp</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;htmls所有标签&quot;&gt;&lt;a href=&quot;#htmls所有标签&quot; class=&quot;headerlink&quot; title=&quot;htmls所有标签&quot;&gt;&lt;/a&gt;htmls所有标签&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;a&lt;/li&gt;
&lt;li&gt;abbr&lt;/li&gt;
&lt;li&gt;acronym&lt;/li
      
    
    </summary>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>JS对象漫谈</title>
    <link href="http://yoursite.com/2017/11/26/JS%E5%AF%B9%E8%B1%A1%E6%BC%AB%E8%B0%88/"/>
    <id>http://yoursite.com/2017/11/26/JS对象漫谈/</id>
    <published>2017-11-26T04:18:14.000Z</published>
    <updated>2017-11-26T04:22:56.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何转为number"><a href="#如何转为number" class="headerlink" title="如何转为number"></a>如何转为number</h1><ul><li>Number(‘1’) === 1</li><li>parseInt(‘1’, 10) === 1</li><li>parseFloat(‘1.23’) === 1.23</li><li>‘1’ - 0 </li><li>+‘1’</li></ul><h1 id="全局对象window"><a href="#全局对象window" class="headerlink" title="全局对象window"></a>全局对象window</h1><ul><li>浏览器在加载时首先会创建window对象</li><li>window的属性分为两类： ECMAScript规定的和浏览器私有的（alert，prompt，confirm，console, history, document等）</li><li>document属于dom规范范畴 ,history属于bom规范范畴</li></ul><h1 id="详解Number"><a href="#详解Number" class="headerlink" title="详解Number"></a>详解Number</h1><ul><li>Number(‘1’) 类型转换</li><li>var n = new Number(1) 1 =&gt; {valueOf(): 1,..},通过valueOf获取到原始值1</li><li>使用直接量赋值 var n = 1;在早期是没有toString方法的，而现在直接使用toString会临时转换为Number对象包装后的“1”然后使用toString，最后把这个包装对象丢掉（磨砂次）,这就是为什么给n.xxx = 1后，然后取n.xxx是undefined的原因</li></ul><h1 id="parseInt-与-toString进制问题"><a href="#parseInt-与-toString进制问题" class="headerlink" title="parseInt 与 toString进制问题"></a>parseInt 与 toString进制问题</h1><ul><li>parseInt第二个形参传入一个进制，代表将第一个实参是什么进制的，然后转化为10进制输出</li><li>toString可以传入一个参数代表将要转化的进制，把调用者转化为对应进制的字符串</li></ul><h1 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h1><ul><li>为什么叫slice？外国人切面包叫slice，js slice可以“切”数组，字符串。</li></ul><h1 id="5个falsy值"><a href="#5个falsy值" class="headerlink" title="5个falsy值"></a>5个falsy值</h1><ul><li>0</li><li>NaN</li><li>‘’</li><li>null</li><li>undefined</li><li>false</li></ul><blockquote><p>所有对象都是真值</p></blockquote><h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><blockquote><p>var o1 = {};</p><p>o1.<strong>proto</strong> ===  Object.prototype</p><p>var n1 = new Number(1)</p></blockquote><p>n1.<strong>proto</strong> === Number.prototype</p><p>n1.<strong>proto</strong>.<strong>proto</strong> === Object.prototype</p><h1 id="proto-和-prototype"><a href="#proto-和-prototype" class="headerlink" title="proto 和 prototype"></a><strong>proto</strong> 和 prototype</h1><p>String.prototype是String的公用属性的引用</p><p>s.<strong>proto</strong> 也是String的公用属性的引用</p><p>var 对象 = new 函数();</p><p>对象.<strong>proto</strong> === 函数.prototype 它们的值是 <a href="原型对象，一个对象或null">[Prototype]</a></p><p>var obj = 函数.prototype</p><p>obj.<strong>proto</strong>  === Object.prototype</p><p>var obj2 = 函数</p><p>obj2.<strong>proto</strong> === Function.prototype</p><p>Function.<strong>proto</strong> === Function.prototype</p><p>Function,prototype.<strong>proto</strong> === Object.prototype</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;如何转为number&quot;&gt;&lt;a href=&quot;#如何转为number&quot; class=&quot;headerlink&quot; title=&quot;如何转为number&quot;&gt;&lt;/a&gt;如何转为number&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Number(‘1’) === 1&lt;/li&gt;
&lt;li&gt;parse
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>武汉光谷国际人工智能产业峰会</title>
    <link href="http://yoursite.com/2017/11/19/%E6%AD%A6%E6%B1%89%E5%85%89%E8%B0%B7%E5%9B%BD%E9%99%85%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BA%A7%E4%B8%9A%E5%B3%B0%E4%BC%9A/"/>
    <id>http://yoursite.com/2017/11/19/武汉光谷国际人工智能产业峰会/</id>
    <published>2017-11-19T03:37:36.000Z</published>
    <updated>2018-02-13T02:08:36.623Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文不探讨人工智能深入的知识，只是个人的一些感受与大家分享</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="./content.jpg" alt="人工智能的趋势" title="">                </div>                <div class="image-caption">人工智能的趋势</div>            </figure><p>是不是治好了你的颈椎病？（逃）</p><h1 id="人工智能强势登场"><a href="#人工智能强势登场" class="headerlink" title="人工智能强势登场"></a>人工智能强势登场</h1><p>记得会场上IEEE Fellow蔡自兴院士说了一句让我印象十分深刻话，他说年轻人不要偷懒哦，小心机器人取代你。对啊，随着人工智能的发展，计算机从计算到感知到认知，可以想象在将来的某一天，机器人也有情感，它将不再是一堆冰冷的钢铁，而是一个有趣的小伙或是一个小姑娘。</p><p>上面这幅图讲述了人工智能可能会替代的职业，从电话推销员到政府职员，涉及面覆盖的很广，我想这只是其中的一部分而不是全部。可见人工智能的威力。</p><h1 id="why-AI？"><a href="#why-AI？" class="headerlink" title="why AI？"></a>why AI？</h1><p>互联网行业是近几年的热门，非计算机专业的人都想来这里捞一桶金，然而随着发展，互联网的流量能挣到的钱正在消失，维护的成本在日益增加。人工智能的处理代替传统人力工作，从一定程度上降低的这方面的成本，所以这是为什么目前国家在大力开展人工智能的建设的原因之一。</p><h1 id="简单的AI思想"><a href="#简单的AI思想" class="headerlink" title="简单的AI思想"></a>简单的AI思想</h1><p>现在有一个场景，国外有些职场人士每天喜欢喝热的咖啡，他们需要看咖啡机里的咖啡是否是满的，是否是热的，是否已经空了等等情况来做出加热，加水等操作，如果把这个交给人工智能来做，应该怎么做呢？</p><p>会上讲到一种思路是使用value function</p><table><thead><tr><th style="text-align:center"></th><th>on</th><th>off</th></tr></thead><tbody><tr><td style="text-align:center">full</td><td>-2</td><td>-5</td></tr></tbody></table><blockquote><p>value function</p></blockquote><p>左侧代表咖啡机是否装满了，右侧代表是否开启加热功能时的状态，用这种映射关系来指挥计算机。当函数的自变量为-2时，会得到一个状态：咖啡机满了且需要加热。</p><h1 id="个人的奇思妙想"><a href="#个人的奇思妙想" class="headerlink" title="个人的奇思妙想"></a>个人的奇思妙想</h1><p>如果机器人有了情感他会听人类的吗？</p><p>比方说现在用生物技术做出了一种生物，你觉得你能很好的控制它么？</p><p>这就像当老师管学生一样，老师说的大道理再多，学生会去执行吗？</p><p>同理你每天命令有感情的计算机工作，它会不会厌烦了。</p><p>当然，这只是个人拙见，还待科学家解释。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文不探讨人工智能深入的知识，只是个人的一些感受与大家分享&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
   
      
    
    </summary>
    
    
      <category term="AI" scheme="http://yoursite.com/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>开博大吉</title>
    <link href="http://yoursite.com/2017/11/18/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/"/>
    <id>http://yoursite.com/2017/11/18/开博大吉/</id>
    <published>2017-11-18T11:40:30.000Z</published>
    <updated>2017-11-18T11:50:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开博大吉"><a href="#开博大吉" class="headerlink" title="开博大吉"></a>开博大吉</h1><blockquote><p>一名初入行的小前端的个人博客,原博客地址博客园酱板鸡。</p></blockquote><p>​                                                            </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;开博大吉&quot;&gt;&lt;a href=&quot;#开博大吉&quot; class=&quot;headerlink&quot; title=&quot;开博大吉&quot;&gt;&lt;/a&gt;开博大吉&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;一名初入行的小前端的个人博客,原博客地址博客园酱板鸡。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="get started" scheme="http://yoursite.com/tags/get-started/"/>
    
  </entry>
  
  <entry>
    <title>Hexo食用教程</title>
    <link href="http://yoursite.com/2017/11/18/Hexo%E9%A3%9F%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/11/18/Hexo食用教程/</id>
    <published>2017-11-18T11:00:30.000Z</published>
    <updated>2017-11-18T11:36:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><blockquote><p>npm install -g hexo-cli</p></blockquote><h1 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h1><blockquote><p>hexo init  &lt;你博客存储文件夹名字&gt;</p><p>cd &lt;你博客存储文件夹名字&gt;</p><p>npm i</p></blockquote><h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><blockquote><p>npm init blog</p><p>cd blog</p><p>npm i</p></blockquote><h1 id="修改配置文件-config-yml"><a href="#修改配置文件-config-yml" class="headerlink" title="修改配置文件_config.yml"></a>修改配置文件_config.yml</h1><blockquote><p>deploy: </p><p>​    type: git</p><p>​    repo: <your git="" repository=""></your></p></blockquote><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><blockquote><p>npm install hexo-deployer-git –save</p><p>hexo deploy</p></blockquote><h1 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h1><blockquote><p>hexo new <blog name=""> //新建文章</blog></p><p>hexo g       //生成静态件</p><p>hexo deploy          //发布</p></blockquote><h1 id="feel-interesting"><a href="#feel-interesting" class="headerlink" title="feel interesting?"></a>feel interesting?</h1><p>do it!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;npm install -g hexo-cli&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;建站&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
