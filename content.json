{"meta":{"title":"1024子翔的程序人生","subtitle":null,"description":null,"author":"林子翔","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"带着如何开放不使用jwt路由而阅读koa-jwt源码引出对koa-unless的阅读","slug":"带着如何开放不使用jwt路由而阅读koa-jwt源码引出对koa-unless的阅读","date":"2018-01-21T05:24:01.000Z","updated":"2018-01-21T06:08:37.784Z","comments":true,"path":"2018/01/21/带着如何开放不使用jwt路由而阅读koa-jwt源码引出对koa-unless的阅读/","link":"","permalink":"http://yoursite.com/2018/01/21/带着如何开放不使用jwt路由而阅读koa-jwt源码引出对koa-unless的阅读/","excerpt":"","text":"问题引入想往项目里面加入401状态，而考虑使用比较公认的jwt技术，遇到一个问题，就是如何开放一些不需要token的路由？ 尝试获取资料于是寻找github上面一些使用jwt验证的项目阅读其中的源码，然而发现都不是自己原生使用jsonwebtoken而是用的express-jwt和koa-jwt，而这两个库都有我尝试解决的问题的解决方案，于是我找到koa-jwt的源码，发现里面使用了koa-unless库，这个库是干嘛的呢，实际是让你指定的路由跳过当前的中间件，那么看看源码。 阅读koa-unless源码1234567891011121314151617181920/** Creates a wrapper middleware that verifies if the original middleware should be skipped. */module.exports = function(options) &#123; var originalMiddleware = this; // If a custom function was passed directly, creates a new object literal that holds it as a property called custom. var opts = typeof options === 'function' ? &#123; custom: options &#125; : options; // Returns the middleware that wraps the original one. return function *(next) &#123; var requestedUrl = url.parse((opts.useOriginalUrl ? this.originalUrl : this.url) || '', true); // any match means 'skip original middleware' if (matchesCustom(this, opts) || matchesPath(requestedUrl, opts) || matchesExtension(requestedUrl, opts) || matchesMethod(this.method, opts)) &#123; return yield *next; &#125; yield *originalMiddleware.call(this, next); &#125;;&#125;; 关键地方 12var originalMiddleware = this;//这里获取当前要跳过的中间件实例 1234if (matchesCustom(this, opts) || matchesPath(requestedUrl, opts) || matchesExtension(requestedUrl, opts) || matchesMethod(this.method, opts)) &#123; return yield *next; //这里判断参数匹配的话，就把控制权转移下个中间件，从而跳过该中间件 &#125; 12yield *originalMiddleware.call(this, next);//这一句结合上面一句来看就是参数不匹配就执行当前中间件 总结总的思路是不执行jwt的验证的中间件，思路其实也很直接，那我就愉快的借用一下罗。~_~! ps国外源码注释真的很清晰，其实在工作中应该也效仿。","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"node流程控制之串行","slug":"node流程控制之串行","date":"2018-01-18T10:22:28.000Z","updated":"2018-01-18T10:33:02.050Z","comments":true,"path":"2018/01/18/node流程控制之串行/","link":"","permalink":"http://yoursite.com/2018/01/18/node流程控制之串行/","excerpt":"","text":"1234567891011121314151617181920212223242526272829function process1() &#123; setTimeout(function() &#123; var process1Result = 1; next(null, process1Result) &#125;,10)&#125;function process2(data) &#123; setTimeout(function() &#123; if (data === 1) var process2Result = 2; next(null, process2Result) &#125;)&#125;function process3(data) &#123; console.log(data);&#125;var taskList = [ process1, process2, process3]next(err, result) &#123; if (err) throw err; var current = taskList.shift(); current &amp;&amp; current(result);&#125;next(); 流程控制 在node中让一组异步操作顺序执行的套路叫做流程控制，而这其中又分为串行流程和并行流程 串行流程 所谓串行流程，即一个接着一个做的流程叫做串行流程，上述代码即一个串行流程的实现。 首先有三个操作，顺序依次为process1，process2，process3， 整个过程的核心是这个next函数，跟node一些框架中交出控制权的next名字是一样的 思路就是按照索引的顺序执行函数，函数中异步调用的返回值，作为下一个next中执行的函数的参数，保证了数据不会丢失。","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"Node编程基础","slug":"Node编程基础","date":"2018-01-11T05:59:29.000Z","updated":"2018-01-11T06:00:40.275Z","comments":true,"path":"2018/01/11/Node编程基础/","link":"","permalink":"http://yoursite.com/2018/01/11/Node编程基础/","excerpt":"","text":"Node编程基础如何组织代码 模块是Node让代码易于重用的一种组织和包装方式 传统方式按逻辑把单个文件分为多个文件，但这些文件互相引用的同时会产生全局变量污染的问题 Node模块打包代码是为了重用，但它们不会改变全局作用域 Node模块允许你从被引入文件中选择要你暴露给程序的函数和变量，如果模块返回的函数和变量不止一个，可以把它们作为exports对象的属性，否则就使用module.exports 如何创建模块 模块既可能是一个文件，也可能是包含一个或多个文件的目录。如果模块是一个目录，Node通常会在这个目录下找一个叫index.js的文件作为模块的入口 使用模块要用到require函数，require是Node中少数几个同步I/O操作之一 用node_modules重用模块 要求模块在文件系统中使用相对路径存放，对于组织程序特定的代码很有帮助，但是与他人共享代码却用处不大。Node的node_modules机制可以不必知道模块在文件系统中的具体位置。 node_modules的搜寻机制如下： 1.开始在文件同一目录下寻找； 2.没有找到，就在当前目录node_modules下找 3.没有找到，进入父目录，再找当前目录node_modules中有没有，重复3； 4.没有找到，找环境变量NODE_PATH指定目录中是否存在； 5没有找到，异常。 异步编程技术 事件发生会触发响应逻辑。 在Node事件里流行两种响应逻辑的管理方式： 回调 回调通常用来定义一次性响应逻辑。比如数据库查询，可以指定一个回调函数来确定如何处理查询结果。这个回调函数可能会显示数据数据库查询结果，根据这些结果做些计算，或者以查询结果为参数执行另一个回调函数 事件监听 事件监听器，本质上也是一个回调，不同的是，它跟一个事件相关联。在Node中，当有HTTP请求过来时，此时服务器会产生一个事件，事件监听器就可以监听这个事件，并添加一些响应的逻辑。 一个Node HTTP服务器实例就是一个事件发射器 能够继承和添加事件发射及处理能力的类（EventEmitter） （未完待续）","categories":[],"tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"基本视觉格式化","slug":"基本视觉格式化","date":"2018-01-11T05:48:33.000Z","updated":"2018-01-16T05:27:23.091Z","comments":true,"path":"2018/01/11/基本视觉格式化/","link":"","permalink":"http://yoursite.com/2018/01/11/基本视觉格式化/","excerpt":"","text":"基本视觉格式化基本框 css假定每个元素都会生成一个或多个矩形框，这称为元素框。各元素框中心有一个内容区。这个内容区周围有可选的内边距，边框和外边距。 包含块（布局上下文） 每个元素都相对于其包含块摆放。正常流中的一个元素，其包含块由最近的块级祖先框、表单元格或行内块祖先框的内容边界构成。 正常流是指西方语言文本从左向右、从上向下显示。大多数元素都在正常流中，除了浮动或定位元素。 块级元素 一般一个基本框从左到右有这几个部分： 左外边界 左外边距 左边框 左内边距 左内边界 内容区宽度 右内边界 右内边距 右边框 右外边距 右外边界 一般地，一个元素的宽度（width）被定义为从左内边界到右内边界的距离，高度同理。高度和宽度属性都可以应用到元素。 不同的宽度、高度、内边距和外边距相结合，就可以确定文档的布局。 水平格式化 区分width和可见元素框的宽度，width属性是不包含padding和margin的（例外的是使用了CSS3的box-sizing），而可见元素框宽度是包含了padding和margin的 有个规则，正常流中块级元素框的水平部分总和就等于父元素width。这一句话即所有子元素的width加上它们的左、右内边距，边框和外边距就是父元素的width。 水平属性 水平格式化有7大属性，从左至右，分别是：margin-left, border-left,padding-left,width,padding-right,border-right,margin-right。这7个属性的值加在一起必须是元素包含块的宽度，这往往是块元素的的父元素的width。 这7大属性只有其中3个可以设置为auto（width，margin-left,margin-right） 使用auto（不考虑3个值以外的属性） 3个auto（margin-left,width,margin-right均为auto），其中width会占满父元素width，而margin-left,margin-right为0 2个auto（比如margin-left,width为auto），这时设置auto的属性会为0，width会将父元素width的剩余空间占满 1个auto，如果设置3个值其中一个为auto，那么设置auto的属性会确定所需的长度，保证3个值加起来等于父元素的width 0个auto同时三者设置的和超过父元素width，则margin-right会为auto。 （未完待续） 负外边距 外边距可以为负 7个水平属性总和要等于父元素的width，严格的说这个总和不能比包含块更宽。所以当外边距为负时子元素的width会超过父元素width，达到一种超出的效果 只要所有属性都是大于或等于0的，元素就不会大于父元素的内容区 百分数 值声明为长度还是百分数，并没有改变上述水平格式化规则","categories":[],"tags":[{"name":"css读书笔记","slug":"css读书笔记","permalink":"http://yoursite.com/tags/css读书笔记/"}]},{"title":"前端工作遇到的小知识点","slug":"前端工作遇到的小知识点","date":"2018-01-09T02:21:41.000Z","updated":"2018-01-17T10:23:13.648Z","comments":true,"path":"2018/01/09/前端工作遇到的小知识点/","link":"","permalink":"http://yoursite.com/2018/01/09/前端工作遇到的小知识点/","excerpt":"","text":"顶部子元素的margin-top直接到父元素上，目前简单的处理方法将子元素margin-top变成父元素padding-top,感觉其他方式也可以解决比如改变BFC，需要补一下BFC，还不太熟 微信小程序中，纵向的高度一定不要px，否则到不同屏幕上差异很明显，横向如果写滑动的效果，计算的left值可以用px，因为获取到的屏幕的宽度是一个以px为单位的值，用px才不会出现位置上偏移的问题。 文本溢出无法实现时，使用height,line-height,overflow做 做列表勾选同步时，前端修改了数据勾选状态，如果请求后端同步时失败，应回滚前端勾选状态，这中列表数据自带勾选状态的做法，也是一种性能优化的经验 接口全局配置，如果有两套环境（生产和测试），在页面里用到相关接口url，必须通过配置文件来引用，而不是直接写，如果有不同，就切分字符串，不然你绝对会不停的改来改去。 原生小程序，setData方法绝对不能set一个undefined值，否则真机会报一个null的错误，同时定位这种错误的方法是打console看这个null的log在console的前面还是后面来定位，巨坑哦 此文长期更新，遇到什么就写什么，mark","categories":[],"tags":[{"name":"工作","slug":"工作","permalink":"http://yoursite.com/tags/工作/"}]},{"title":"html标签","slug":"html标签","date":"2018-01-05T05:24:08.000Z","updated":"2018-01-05T05:40:43.981Z","comments":true,"path":"2018/01/05/html标签/","link":"","permalink":"http://yoursite.com/2018/01/05/html标签/","excerpt":"","text":"htmls所有标签 a abbr acronym address applet area article aside audio b base basefont bdi bdo bgsound big blink blockquote body br button canvas caption center cite code col colgroup command content data datalist dd del details dfn dialog dir div dl dt element em embed fieldset figcaption figure font footer form frame frameset h1~h6 head header hgroup hr html i iframe image(请勿使用，从未实现) img input ins isindex kbd keygen label legend li link listing main map mark marquee menu menuitem meta meter multicol nav nextid nobr noembed noframes noscript object ol optgroup option output p param picture plaintext pre progress q rp rt rtc ruby s samp script section select shadow slot small Source spacer span strike strong style sub summary sup table tbody td template textarea tfoot th thead time title tr track tt u ul var video wbr xmp","categories":[],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"JS对象漫谈","slug":"JS对象漫谈","date":"2017-11-26T04:18:14.000Z","updated":"2017-11-26T04:22:56.288Z","comments":true,"path":"2017/11/26/JS对象漫谈/","link":"","permalink":"http://yoursite.com/2017/11/26/JS对象漫谈/","excerpt":"","text":"如何转为number Number(‘1’) === 1 parseInt(‘1’, 10) === 1 parseFloat(‘1.23’) === 1.23 ‘1’ - 0 +‘1’ 全局对象window 浏览器在加载时首先会创建window对象 window的属性分为两类： ECMAScript规定的和浏览器私有的（alert，prompt，confirm，console, history, document等） document属于dom规范范畴 ,history属于bom规范范畴 详解Number Number(‘1’) 类型转换 var n = new Number(1) 1 =&gt; {valueOf(): 1,..},通过valueOf获取到原始值1 使用直接量赋值 var n = 1;在早期是没有toString方法的，而现在直接使用toString会临时转换为Number对象包装后的“1”然后使用toString，最后把这个包装对象丢掉（磨砂次）,这就是为什么给n.xxx = 1后，然后取n.xxx是undefined的原因 parseInt 与 toString进制问题 parseInt第二个形参传入一个进制，代表将第一个实参是什么进制的，然后转化为10进制输出 toString可以传入一个参数代表将要转化的进制，把调用者转化为对应进制的字符串 slice 为什么叫slice？外国人切面包叫slice，js slice可以“切”数组，字符串。 5个falsy值 0 NaN ‘’ null undefined false 所有对象都是真值 原型 var o1 = {}; o1.proto === Object.prototype var n1 = new Number(1) n1.proto === Number.prototype n1.proto.proto === Object.prototype proto 和 prototypeString.prototype是String的公用属性的引用 s.proto 也是String的公用属性的引用 var 对象 = new 函数(); 对象.proto === 函数.prototype 它们的值是 [Prototype] var obj = 函数.prototype obj.proto === Object.prototype var obj2 = 函数 obj2.proto === Function.prototype Function.proto === Function.prototype Function,prototype.proto === Object.prototype","categories":[],"tags":[]},{"title":"武汉光谷国际人工智能产业峰会","slug":"武汉光谷国际人工智能产业峰会","date":"2017-11-19T03:37:36.000Z","updated":"2017-11-19T04:23:19.000Z","comments":true,"path":"2017/11/19/武汉光谷国际人工智能产业峰会/","link":"","permalink":"http://yoursite.com/2017/11/19/武汉光谷国际人工智能产业峰会/","excerpt":"","text":"本文不探讨人工智能深入的知识，只是个人的一些感受与大家分享 人工智能的趋势 是不是治好了你的颈椎病？（逃） 人工智能强势登场记得会场上IEEE Fellow蔡自兴院士说了一句让我印象十分深刻话，他说年轻人不要偷懒哦，小心机器人取代你。对啊，随着人工智能的发展，计算机从计算到感知到认知，可以想象在将来的某一天，机器人也有情感，它将不再是一堆冰冷的钢铁，而是一个有趣的小伙或是一个小姑娘。 上面这幅图讲述了人工智能可能会替代的职业，从电话推销员到政府职员，涉及面覆盖的很广，我想这只是其中的一部分而不是全部。可见人工智能的威力。 why AI？互联网行业是近几年的热门，非计算机专业的人都想来这里捞一桶金，然而随着发展，互联网的流量能挣到的钱正在消失，维护的成本在日益增加。人工智能的处理代替传统人力工作，从一定程度上降低的这方面的成本，所以这是为什么目前国家在大力开展人工智能的建设的原因之一。 简单的AI思想现在有一个场景，国外有些职场人士每天喜欢喝热的咖啡，他们需要看咖啡机里的咖啡是否是满的，是否是热的，是否已经空了等等情况来做出加热，加水等操作，如果把这个交给人工智能来做，应该怎么做呢？ 会上讲到一种思路是使用value function on off full -2 -5 value function 左侧代表咖啡机是否装满了，右侧代表是否开启加热功能时的状态，用这种映射关系来指挥计算机。当函数的自变量为-2时，会得到一个状态：咖啡机满了且需要加热。 个人的奇思妙想如果机器人有了情感他会听人类的吗？ 比方说现在用生物技术做出了一种生物，你觉得你能很好的控制它么？ 这就像当老师管学生一样，老师说的大道理再多，学生会去执行吗？ 同理你每天命令有感情的计算机工作，它会不会厌烦了。 当然，这只是个人拙见，还待科学家解释。","categories":[],"tags":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/tags/AI/"}]},{"title":"开博大吉","slug":"开博大吉","date":"2017-11-18T11:40:30.000Z","updated":"2017-11-18T11:50:59.000Z","comments":true,"path":"2017/11/18/开博大吉/","link":"","permalink":"http://yoursite.com/2017/11/18/开博大吉/","excerpt":"","text":"开博大吉 一名初入行的小前端的个人博客,原博客地址博客园酱板鸡。 ​","categories":[],"tags":[{"name":"get started","slug":"get-started","permalink":"http://yoursite.com/tags/get-started/"}]},{"title":"Hexo食用教程","slug":"Hexo食用教程","date":"2017-11-18T11:00:30.000Z","updated":"2017-11-18T11:36:22.000Z","comments":true,"path":"2017/11/18/Hexo食用教程/","link":"","permalink":"http://yoursite.com/2017/11/18/Hexo食用教程/","excerpt":"","text":"安装 npm install -g hexo-cli 建站 hexo init &lt;你博客存储文件夹名字&gt; cd &lt;你博客存储文件夹名字&gt; npm i example npm init blog cd blog npm i 修改配置文件_config.yml deploy: ​ type: git ​ repo: 部署 npm install hexo-deployer-git –save hexo deploy 写作 hexo new //新建文章 hexo g //生成静态件 hexo deploy //发布 feel interesting?do it!","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}