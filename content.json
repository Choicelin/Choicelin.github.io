{"meta":{"title":"1024子翔的程序人生","subtitle":null,"description":null,"author":"Choicelin","url":"http://yoursite.com"},"pages":[{"title":"","date":"2018-01-21T07:47:17.529Z","updated":"2018-01-21T07:47:17.529Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-01-21T07:46:56.371Z","updated":"2018-01-21T07:46:56.371Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ESLIN配置airbnb标准","slug":"ESLIN配置airbnb标准","date":"2018-08-25T01:20:18.000Z","updated":"2018-08-25T01:36:33.667Z","comments":true,"path":"2018/08/25/ESLIN配置airbnb标准/","link":"","permalink":"http://yoursite.com/2018/08/25/ESLIN配置airbnb标准/","excerpt":"","text":"安装依赖1234( export PKG=eslint-config-airbnb; npm info &quot;$PKG@latest&quot; peerDependencies --json | command sed &apos;s/[\\&#123;\\&#125;,]//g ; s/: /@/g&apos; | xargs npm install --save-dev &quot;$PKG@latest&quot;) (linux || mac osx) 命令行操作1eslint --init 选use popular style guide -&gt;接着选airbnb-&gt;根据需要选择是否要react-&gt;config格式选json 这样会创建一个.eslintrc.json IDE举例 webstorm中Preference中搜索eslint然后选择automatic search，这样ide会自动寻找eslintrc 你会发现格式化的时候与eslint的配置的检查相冲突，那么需要单独配置，具体方法是根据格式化以后的报错信息在Code Style -&gt; javascript中修改格式化方式 总结最可操作，最简单的方式就是这样，欢迎尝试","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"css积累一","slug":"css积累一","date":"2018-08-24T11:03:59.000Z","updated":"2018-08-24T11:13:13.517Z","comments":true,"path":"2018/08/24/css积累一/","link":"","permalink":"http://yoursite.com/2018/08/24/css积累一/","excerpt":"","text":"span,text之间的换行会导致空格的出现，引出一些样式bug border写了下方要在上方补一个透明的，同适用于padding，为了垂直居中，水平方向也是 div高度由其内部文档流元素的高度总和决定 文档流是文档内元素的流动方向 内联元素从左往右遇到宽度不够换行，英文是以单词为整体换行如果要字母截断使用word-break: break-all;否则是break-word 块级元素每一个块占一行，从上往下 span高度与字体的各种因素决定，无法确定 字体font-size大小指字最高到最低处的高度，每个字体都有建议行高，是由设计师确定的 遇到div中有内联元素要确定高度必须写height","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"微信小程序一次性事件实现","slug":"微信小程序一次性事件实现","date":"2018-08-24T08:14:56.000Z","updated":"2018-08-24T08:17:46.505Z","comments":true,"path":"2018/08/24/微信小程序一次性事件实现/","link":"","permalink":"http://yoursite.com/2018/08/24/微信小程序一次性事件实现/","excerpt":"","text":"场景在开发原生小程序时，可能会一种场景，比如我对某一个点击事件，多次点击只触发一次，这是常见的once函数做的事情，但是如何用在小程序里面呢，下面给大家看看我的处理方法。 once函数123456789101112131415function once(fn, context) &#123; return function() &#123; if (fn) &#123; fn.apply(context || this, arguments) fn = null &#125; &#125;&#125; 小程序代码示例 wxml 1&lt;view bindtap=\"click\"&gt;点我&lt;/view&gt; js 12345678910111213141516171819202122232425262728293031323334353637383940414243Page(&#123; data: &#123;&#125;, result: null, onLoad: function () &#123; this.result = once(this.actualClick, this) &#125;, actualClick() &#123; console.log(1) &#125;, click() &#123; this.result() &#125;,&#125;)function once(fn, context) &#123; return function() &#123; if (fn) &#123; fn.apply(context || this, arguments) fn = null &#125; &#125;&#125; 总结once返回的函数要存起来，而且只存一次，并且要获取到page实例，所以需要在onload里面初始化。","categories":[],"tags":[{"name":"记录","slug":"记录","permalink":"http://yoursite.com/tags/记录/"}]},{"title":"JAVA基本语法cheatsheet","slug":"JAVA基本语法cheatsheet","date":"2018-08-24T07:55:37.000Z","updated":"2018-08-24T08:11:11.889Z","comments":true,"path":"2018/08/24/JAVA基本语法cheatsheet/","link":"","permalink":"http://yoursite.com/2018/08/24/JAVA基本语法cheatsheet/","excerpt":"","text":"基本数据类型 整数 浮点数 字符 数组 布尔 表达式和语句变量和赋值控制语句循环控制语句JAVA类型模型类与对象 （抽象与具体）类 类是一个模板 对象 JAVA语言一等公民，对象可以赋值到一个变量 行为与状态（方法与成员变量）执行行为改变状态 成员方法 静态方法 重载 由方法名与参数类型确定 修饰符 final 类将不能继承，变量将是常量，方法防重写， 常量如果是对象其内部也是可以修改的 访问修饰符 public protected default private 同一个类 1 1 1 1 同一个包 1 1 1 0 子父类 1 1 0 0 不同包 1 0 0 0 包和层次结构 命名空间","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]},{"title":"JAVA学习一","slug":"JAVA学习一","date":"2018-08-05T11:35:58.000Z","updated":"2018-08-05T12:27:09.339Z","comments":true,"path":"2018/08/05/JAVA学习一/","link":"","permalink":"http://yoursite.com/2018/08/05/JAVA学习一/","excerpt":"","text":"LinuxLinux是一个内核负责管理硬件的计算与存储。内核包含很多驱动，它们都是内核的一个个模块。软件驱动了硬件，向上提供了接口。 我们需要掌握的是：文件系统，内存管理（调度算法），进程，进程间通信。 面向接口开发需求 =&gt; 接口 =&gt; 实现 Linux架构​ 应用程序 shell library ​ 系统调用 ​ 内核 ​ 硬件 ​ Linux架构 系统调用指操作系统内核提供“函数调用”，内核和应用的唯一的接口 文件系统/ 根目录 /home 用户目录 /var 经常变化的文件，比如日志（分区可以使用ssd硬盘） /usr 用户程序 /bin 可执行程序 /boot 引导系统启动 /tmp 临时文件 /lib, /lib64 系统库文件 /etc 配置文件 /proc 进程信息 关于分区，我们不需要关注底层是如何分区，只需关心文件的这些目录，这样就把底层解耦了，所以文件系统也是一种接口。 终端 SHELL 管道终端（终端模拟器） SHELL 执行命令 用户与系统的交互接口 管道 连接输出与输入 程序与进程的关系，没有加载到内存中运行的叫程序，否则叫进程 Linux中一切都是文件 包括标准输入，标准输出，标准错误都是文件的名字 命令行chmod修改文件权限 文件权限有10位 第一位代码文件是目录是文件还是链接，然后每隔三位代表读写可执行权限 赋权 chmod (u|g|o) (+|-) (r|w|x) 管道示例 cat a.log | grep error |wx -l 统计a.log中错误error出现的行数 精髓学习时整体要有一个宏观的把握，包括api层，业务逻辑层，数据存储层，每到一个阶段要知道学到哪里了。 欢迎加入Java工坊 qq群570535816 全栈工坊qq群306204564","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]},{"title":"谈谈引用和求值策略","slug":"谈谈引用和求值策略","date":"2018-07-23T02:32:25.000Z","updated":"2018-08-05T11:35:33.580Z","comments":true,"path":"2018/07/23/谈谈引用和求值策略/","link":"","permalink":"http://yoursite.com/2018/07/23/谈谈引用和求值策略/","excerpt":"","text":"说说引用值搞清楚引用之前先看看值是什么。在计算机科学中，一个值代表了一个程序可操作控制的实体。某种数据类型的一些成员就是这种类型的一些值。 指针在计算机科学中，指针是一个对象，它存储了另一个在内存中值的内存地址。一个指针引用了内存中的一个位置。 地址在计算机中，一个内存地址是一个对一块特定内存位置的引用。 引用在计算机科学中，引用是一个值，它能够让程序在内存或其他设备存储中间接获取到特定的数据，比如变量的值或者一个记录。对一个给定系统中存储在内存中的引用，它的实现是数据存储在内存或其他设备存储空间中的物理地址。但是正是由于刚才这种说法导致了大家对指针和地址的错误的混淆，并说一个引用是指向了这个数据。然而，引用的可能以其他的方式来实现。 小结引用不是指针，因为它可能实现方式是保存了一个物理地址，也可能是别的方式，比存的一个相对的地址偏移，而指针则是保存一个物理地址，显得更加狭义一点。同时，引用是一个值。 说说求值策略求值策略是程序语言决定什么时候来求一个函数调用的实参的值，同时计算什么类型的值来传递给一个函数。 通过值调用通过值调用也被说是传递值。在这种方式中，实参表达式被计算的结果会绑定到调用后相匹配的变量上（对应于形参的位置），并且将这个值复制后放到一个新的内存区域。这种方式的特点是，函数作用域外的被传递的变量是不变的。 通过引用调用通过引用调用也被说是传递引用。在这种方式中，函数接受一个变量的隐式引用作为实参，而不是它的值的拷贝。这种方式的特点是，函数作用域外被传递的变量也会被改变。 通过共享调用通过共享调用也被说是通过对象或通过对象共享调用，Java，Python，JavaScript中都存在这中求值策略。关键在于传递的是一个对象，这个对象并没有被复制放到一个新的内存区域，而是在调用者和被调用者的作用域中共享着。和通过值调用的不同是，这个对象在调用者作用域中被修改了。和通过引用调用的不同是，获取值的权限并不在调用者，因为传递的不是一个引用，而是一个对象。","categories":[],"tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://yoursite.com/tags/计算机科学/"}]},{"title":"在vue中配置使用SCSS预编译","slug":"在vue中配置使用SCSS预编译","date":"2018-07-18T11:12:15.000Z","updated":"2018-08-05T11:35:33.580Z","comments":true,"path":"2018/07/18/在vue中配置使用SCSS预编译/","link":"","permalink":"http://yoursite.com/2018/07/18/在vue中配置使用SCSS预编译/","excerpt":"","text":"前言 vue-cli 使用webpack模板生成的项目需要引入scss预处理器，网上散人教程不够官方，这里参照官方文档写一个简化步骤 步骤 1234# use npmnpm install sass-loader node-sass --save-dev# use yarnyarn add -D sass-loader node-sass 1234567891011// bulid文件夹下的webpack base配置中的module的rules数组加入以下对象&#123; test: /\\.vue$/, loader: 'vue-loader', options: &#123; loaders: &#123; scss: 'vue-style-loader!css-loader!sass-loader', // &lt;style lang=\"scss\"&gt; sass: 'vue-style-loader!css-loader!sass-loader?indentedSyntax' // &lt;style lang=\"sass\"&gt; &#125; &#125;&#125; style中lang改为scss即可 123&lt;style lang=&quot;scss&quot;&gt;&lt;/style&gt; 需要的同学可以收藏 （逃）","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"在mpvue中使用图表插件wx-charts","slug":"在mpvue中使用图表插件wx-charts","date":"2018-07-06T02:00:43.000Z","updated":"2018-08-05T11:35:33.580Z","comments":true,"path":"2018/07/06/在mpvue中使用图表插件wx-charts/","link":"","permalink":"http://yoursite.com/2018/07/06/在mpvue中使用图表插件wx-charts/","excerpt":"","text":"前言 大家在原生小程序中需要用到图表插件时，可能会选择echarts或者由xiaolin3303开发的一款wx-charts插件，本文为大家剖析一下如何在开源小程序框架mpvue中使用wx-charts插件 原理 mpvue编译后的代码是原生的小程序代码，它把页面的wxml内容全部封成了template引入到page中。既然是最后会转为原生代码，就支持使用原生的canvas组件，这一点也是官方明确肯定的。所以在mpvue中使用wx-charts就跟在原生中使用一样，除了注意事件的绑定使用mpvue的方式即可。 步骤1. 1git clone git@github.com:xiaolin3303/wx-charts.git 在clone下来的dist文件夹获得wxcharts-min.js（混淆版本）,如果需要进行二次开发，可以使用wxcharts.js然后修改 内容，达到定制化的目的，修改完后可以利用在线混淆进行重新混淆使用。 12&lt;!--/src/pages/bar/bar.vue template中内容 --&gt;&lt;canvas canvas-id=\"areaCanvas\" class=\"canvas\" @touchstart=\"touchHandler\"&gt;&lt;/canvas&gt; 3.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// /src/pages/bar/bar.vue script中内容var wxCharts = require('@/lib/wxcharts-min.js'); //该路径为该js文件在你项目中的路径export default &#123; name: \"bar\", data() &#123; return &#123; bar: null &#125; &#125;, mounted: function (e) &#123; var windowWidth = 320; try &#123; var res = wx.getSystemInfoSync(); windowWidth = res.windowWidth; &#125; catch (e) &#123; console.error('getSystemInfoSync failed!'); &#125; this.bar = new wxCharts(&#123; canvasId: 'areaCanvas', type: 'area', categories: ['1', '2', '3', '4', '5', '6'], animation: true, series: [&#123; name: '成交量1', data: [32, 45, null, 56, 33, 34], format: function (val) &#123; return val.toFixed(2) + '万'; &#125; &#125;], yAxis: &#123; title: '成交金额 (万元)', format: function (val) &#123; return val.toFixed(2); &#125;, min: 0, fontColor: '#8085e9', gridColor: '#8085e9', titleFontColor: '#f7a35c' &#125;, xAxis: &#123; fontColor: '#7cb5ec', gridColor: '#7cb5ec' &#125;, extra: &#123; legendTextColor: '#cb2431' &#125;, width: windowWidth, height: 200 &#125;); &#125;, methods: &#123; touchHandler: function (e) &#123; console.log(this.bar.getCurrentDataIndex(e)); this.bar.showToolTip(e); &#125; &#125; &#125; 总结 该图表支持tooltip，这个功能比较实用，目前mpvue-echarts是不支持这一点的，但是echarts会更加美观，可以根据需求取舍","categories":[],"tags":[{"name":"心得体会","slug":"心得体会","permalink":"http://yoursite.com/tags/心得体会/"}]},{"title":"浅谈BEM命名法则","slug":"浅谈BEM命名法则","date":"2018-07-01T03:16:33.000Z","updated":"2018-07-01T03:36:38.225Z","comments":true,"path":"2018/07/01/浅谈BEM命名法则/","link":"","permalink":"http://yoursite.com/2018/07/01/浅谈BEM命名法则/","excerpt":"","text":"Block 独立的有意义的实体 比如header, container,menu,checkbox,input Element Block中的没有独立意义，但是语义上与Block有联系的部分 比如menu item,list item,checkbox caption,title,header Modifier Block和Element的标志，用来改变Block和Element的行为 比如disabled,highlighted,checked,fixed,size big,color yellow 常见使用方式举例 12345678910&gt; &lt;button class=\"button\"&gt;&gt; Normal button&gt; &lt;/button&gt;&gt; &lt;button class=\"button button--state-success\"&gt;&gt; Success button&gt; &lt;/button&gt;&gt; &lt;button class=\"button button--state-danger\"&gt;&gt; Danger button&gt; &lt;/button&gt;&gt; 总结 上面的例子用中划线分隔的三个部分就分别是Block,Element,Modifier。为什么要使用BEM方式来命名，从表现形式来看，是为了做到防止命名冲突，同时见名知意，目前有些项目会采取这种方式。 为了防止命名冲突有一种类似的方案是CSS MODULES。 总之命名还是比较重要，大家可以自行取舍，欢迎发邮件与我讨论。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"读王勇人生前28年有感","slug":"读王勇人生前28年有感","date":"2018-06-16T01:56:54.000Z","updated":"2018-06-16T02:37:02.267Z","comments":true,"path":"2018/06/16/读王勇人生前28年有感/","link":"","permalink":"http://yoursite.com/2018/06/16/读王勇人生前28年有感/","excerpt":"","text":"关于名字王勇，前deepIn linux项目负责人，最近因为个人原因离职了。我也是因为公司的同事才知道他这个人的。于是想搜索一下关于他的介绍，然后搜索到了他的一篇文章《我人生的前28年》。 个人感受整体浏览了他的文章，感觉是个做事很直接的人，学习上直击要点，如果要干什么就会直接开始从要学的入手，而且不会有科班生的畏难，可能是他最开始的时候是初生牛犊不怕虎，但是正是这种精神让他敢于去学习一门科班生可能觉得难的东西。这只是个人看法，可能他本人不是这样想的，后来他继续钻研难的技术，我觉得就是他已经掌握了一套学习的方法。他是不像很多现在的普通程序员分java还是php，他基本用什么就学什么，不会区分语言。这一点我听过一个facebook的工程师说过，facebook招人主考算法，人招进去以后，会在各个部门实习两周左右，他们要求无论是前端还是后端，只要公司需要，你都能很快的转入进去，这其实就是考验一个人的思维能力，因为语言到后面只是工具，用这个工具的还是你这个人，人的思维好了，对什么都能快速上手，并且能够举一反三。回到王勇身上，这位前辈体验到了很多人生的辛酸苦辣，但是感觉他一直在编码，这对我也是一种激励， 就是再多挫折也要抗住，就是跌到以后微笑爬起来，而且我希望国内大龄的编码者越来越多，这样就不用所谓的程序员到35岁要转管理这种说法。如果你热爱技术，为什么要转管理，好好做技术不好么。感觉很多喜欢技术的人，都是无法抗拒外界因素转的管理，当然也有最后没机会做管理被淘汰的人，所以我理想的是，没有外界因素，只有一个很直接的工作，coder，能够做到最后。但是目前IT行业年纪最大的估计国内也没有到退休年龄，这些事情不知道最后是个怎么样的。 自我今后我需要学习他的钻劲，啃。无论如何，我都要微笑迎接人生的困难，最后用王勇前辈的一句话结束： 中国教育最大的失败在于他们没有给这些未成年人看到真实残酷的社会， 他们没有教在社会上生存最重要的东西： 就是跌到以后微笑爬起来， 人在社会上最重要的就是你每天都会面对痛苦的事情， 你不喜欢的事情， 不顺心的事情， 最起码在你能力还不能支撑你个人理想的时候， 你要怎么去面对你个人， 你的家人","categories":[],"tags":[{"name":"读后感","slug":"读后感","permalink":"http://yoursite.com/tags/读后感/"}]},{"title":"异步流程控制的两种思路","slug":"异步流程控制的两种思路","date":"2018-05-15T15:13:49.000Z","updated":"2018-05-15T15:14:34.967Z","comments":true,"path":"2018/05/15/异步流程控制的两种思路/","link":"","permalink":"http://yoursite.com/2018/05/15/异步流程控制的两种思路/","excerpt":"","text":"异步流程控制的两种思路 第一种在异步回调里面执行操作，这是最为常见的，扩展一下可以在回调参数里面再传回调，然后这个传入的回调里面执行可以保证异步逻辑走完了 思路二，我称之为赛跑回调，跟第一种有点类似，但是有细微的区别，有一个赛跑的感觉，也是在异步回调里面注册一个回调，把数据放到回调形参，这个回调可以在其他地方调用，在其他地方使用时，判断一下数据是否到位，如果到位了执行你的逻辑，如果没到位，执行回调，接受实参，设置数据，然后再执行你的逻辑。这就好比如果接口跑的快就不用调回调，跑得慢就调，所以好像赛跑一样。","categories":[],"tags":[{"name":"ajax","slug":"ajax","permalink":"http://yoursite.com/tags/ajax/"}]},{"title":"node写接口无响应原因总结","slug":"node写接口无响应原因总结","date":"2018-05-15T15:12:38.000Z","updated":"2018-05-15T15:13:12.523Z","comments":true,"path":"2018/05/15/node写接口无响应原因总结/","link":"","permalink":"http://yoursite.com/2018/05/15/node写接口无响应原因总结/","excerpt":"","text":"可能原因 路由路径不对 未调用next 中间件问题 debug方法 先注释全部路由以外的中间件，然后再依次打开，看是哪个中间件出问题","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"前端工作积累的知识点二","slug":"前端工作积累的知识点二","date":"2018-05-15T15:10:19.000Z","updated":"2018-07-01T09:33:30.145Z","comments":true,"path":"2018/05/15/前端工作积累的知识点二/","link":"","permalink":"http://yoursite.com/2018/05/15/前端工作积累的知识点二/","excerpt":"","text":"picker、scroll-view上使用flex是无效的，需要在内部嵌套一层view再使用flex效果 filter(), concat() 和 slice()均不会修改原数组而是返回一个新数组 php var_dump()查看表达式的值和类型，gettype()类似js typeof, is_type()判断是否是type类型 php 布尔字面量是大写，(bool)可以强转，但是boolean才是类型字符 falsy值： FALSE，0，0.0，””, “0”, [], NULL尚未赋值变量还有一个空标记生成的Si没票了XML对象 php round()四舍五入，int()截断，php没有整除运算符 永远不要比较两个浮点数是否相等，如果硬要比较，可以使用机器极小值（epsilon）或最小单元取整数， 是计算中所能接受的最小的差别值 NAN用is_nan比较检查 用超出字符串长度的下标写入将会拉长该字符串并以空格填充，用负数下标读取字符串时返回空字符串， 写入时只用到了赋值字符串的第一个字符。用空字符串赋值则赋给的值是 NULL 字符 strval()可以转换为字符串，TRUE会被转为”1”,FALSE会被转为”” 小程序app.js中所有接口获取到的内容都可以在小程序全部页面共享，app.global,切记 open页面是为了在A小程序中分享这个open页面，然后根据options，拼参数跳转到B小程序 koa2 ctx.type可以设置Content-Type getter 后面跟的类似function的东西，其实名字是一个对象的属性，在用取值的时候执行里面的逻辑 最佳实践，在初始化生命周期中，拿数据及其配置操作时，最好加loading，在所有数据到位以后再做处理，这也是对异步流程的一种控制，所以说异步走到最后还是类似于同步的处理，也就是异步流程控制 query需要encodeURIComponent的时候不要把整个query进行encode，而是需要排除=，&amp;这种符号，否则会出问题 做手持弹幕，旋转90度时把宽为100vh高为100vw时，变形，是因为旋转中心没有居中，先把div居中(通过定位居中，flex居中会有问题)，再旋转，注意，不是调旋转中心，而是让要旋转的div居中 做定位居中和动画同时使用不同transform时，需要在动画里重复写 设置picker-view value需要setTimeout,但是此时会触发bindchange事件，所以 1234this.pickChangeFlag = falsesetTimeout(() =&gt; &#123; this.pickChangeFlag = true&#125;, 200) 图片加载可以加loading效果，未加载出来的时候，加上background-image给一个loading图片","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"bug心路2","slug":"bug心路2","date":"2018-05-03T16:55:23.000Z","updated":"2018-05-03T17:00:25.232Z","comments":true,"path":"2018/05/04/bug心路2/","link":"","permalink":"http://yoursite.com/2018/05/04/bug心路2/","excerpt":"","text":"今天做一个node项目，遇到一个bug，刚开始没明显报错，定位都没法定位。 至于原因是用了别人的脚手架不太熟悉，这个脚手架把错误处理都搞得较为复杂。 后来搞了很久，把脚手架里面所有的错误处理全部替换为最简单的，然后报错就来了瞬间就解决了。 关于解决问题，如果想要解决就能够解决，现在越来越能够沉着的有耐心的去解决一个问题，对于复杂的东西就简单化，记得当年听一个大哥跟一个小弟，找一个最简单的示例，这个不够简单，再找一个。","categories":[],"tags":[{"name":"心得体会","slug":"心得体会","permalink":"http://yoursite.com/tags/心得体会/"}]},{"title":"给今后解决bug作参考-bug心路","slug":"给今后解决bug作参考-bug心路","date":"2018-04-10T12:57:59.000Z","updated":"2018-04-11T03:13:15.882Z","comments":true,"path":"2018/04/10/给今后解决bug作参考-bug心路/","link":"","permalink":"http://yoursite.com/2018/04/10/给今后解决bug作参考-bug心路/","excerpt":"","text":"解决标准分bug的过程，或许对以后会有所启示，首先觉得是对的，与测试沟通，然后需求说确认要改，然后改，发现代码确实是跳结果页，找不到原因，询问小师父，发现是后台接口的一个问题导致不能支付，然后支付试一下，可以了，但是页面白屏，停一下，到这一步其实是关键，这个白屏的链接获取到，这是个突破点，然后就靠自己了，发现在结果页又发生了跳转，是一个参数控制是否跳转，打印该参数为undefined，取反，正好是触发了跳转，问题就集中在这里，继续刷新看获取该参数的接口跑了没，发现跑了，看是不是时机不对,果然，在render中写跳转，redux中数据还没有过来，换到componentWillReceiveProps里面，成功，bug终结 思考：为什么自己没有坚持到找到白屏链接那一步？值得反思。值得赞赏的是，找到突破口以后，每一步的决策都是对的，从发现突破口到解决只花了很短一段时间。今后应该如何参考这个？首先，我少了一步，就是重现这个bug，只看代码，而不实际去测一下，值得批评。加油，阿翔，今后要成为全栈哦，从自己能够做的入手，不要跟别人比，脚踏实地去做。 分享一下，与我共勉 第二天一来，发现事情并没有结束，支付以后还是跳回stats，没有考虑到一点，componentWillReceiveProps是服务全局的，任何新props来都会触发，就可能出现undefined的情况。 又要批评一下，改完了还是要自己多测一下。","categories":[],"tags":[{"name":"程序人生","slug":"程序人生","permalink":"http://yoursite.com/tags/程序人生/"}]},{"title":"mysql学习笔记","slug":"mysql学习笔记","date":"2018-04-06T00:17:08.000Z","updated":"2018-04-17T02:46:18.679Z","comments":true,"path":"2018/04/06/mysql学习笔记/","link":"","permalink":"http://yoursite.com/2018/04/06/mysql学习笔记/","excerpt":"","text":"mysql命令行mysql登录 查看版本 1mysql -V root权限登录 p密码 P端口 h主机地址 回车后输入密码或者-p后跟密码 1mysql -uroot -p -P3306 -h127.0.0.1 登录后退出123exit;quit;\\q; 修改提示符 \\D完整日期 \\d当前数据库 \\h服务器名称\\u当前用户 可以互相组合 1mysql -uroot -proot --prompt \\h 登录以后 1prompt mysql&gt; 常用命令 查版本、显示当前日期、显示当前用户 123SELECT VERSION();SELECT NOW();SELECT USER(); 规范 关键字、函数名称全部大写 数据库名称、表名称、字段名称全部小写 SQL语句必须以分号结尾 创建数据库示例 最简单的版本 1CREATE DATABASE t1; 在未存在该数据库时才创建 1CREATE DATABASE IF NOT EXISTS t1; 此时数据库存在，所以可以用SHOW WARNINGS;查看警告信息，SHOW CREATE DATABASE t1;可以查看创建t1的命令 再加入编码方式 1CREATE DATABASE IF NOT EXIST t2 CHARACTER SET gbk; 如果想修改编码方式则参考下面的内容 查看当前服务器下的数据列表 基本示例 1SHOW DATABASES; 修改数据库示例 修改除了没有IF NOT EXISTS 和 CREATE改为ALTER其他部分都一样，下面修改字符集 1ALTER DATABASE t1 CHARACTER SET utf8; 删除数据库示例 删除 1DROP DATABASE IF EXISTS t1; MySQL数据类型整型 TINYINT(-128-127,0-255) 1字节 SMALLINT(-32768-32767,0-65535) 2字节 MEDIUMINT(-8388608-8388607,0-4294967295) 3字节 INT(-2^31-2^31-1,0-2^32-1) 4字节 BIGINT(-2^63–2^63-1,0-2^64-1) 8字节 浮点型 FLOAT[(M,D)] M表示总位数D表示小数位数（小数最大7位） DOUBLE[(M,D)] 日期类型 YEAR 1 TIME 3 DATE 3 DATETIME 8 TIMESTAMP(时间戳) 4 字符型 CHAR(M) 0&lt;=M&lt;=255字节 定长类型，不足以空格补位 VARCHAR(M) L+1个字节，其中L&lt;=M且0&lt;=M&lt;=65535 变长类型，有多长存多长 TINYTEXT L+1个字节，其中L&lt;2^8 TEXT L+2个字节，其中L&lt;2^16 MEDIUMTEXT 3 24 LONGTEXT 4 32 ENUM(‘value1’,’value2’,…) 1或2个字节，取决于枚举个数（最多65535个值） SET(‘value1’,’value2’,…) 1 2 3 4 8字节 取决于SET成员的数目最大64个成员 表USE 打开数据库(必须已经创建或已存在) 1USE t1; 创建数据表 创建一个存储用户信息的表 12345CREATE TABLE tb1( username VARCHAR(20), age TINYINT UNSIGNED, salary FLOAT(8,2) UNSIGHED); 查看数据表 查看数据表列表 1SHOW TABLES [FROM dbName(mysql)]; 查看数据表结构 查看表结构是查看列 1SHOW COLUMNS FROM tb1; 插入记录与查询记录 插入记录示例，如果省略列名称，需要全部赋值，还是以上面创建的用户信息表举例 1INSERT tb1 VALUES('Anger', 21, 7863.25); 插入记录示例,不省略列名称 1INSERT tb1(username, age) VALUES('Kira', 25); 简单查询示例，*匹配的是字段而不是记录，有人会说*是匹配所有记录，这是有点问题的 1SELECT * FROM tb1; 空值与非空 NULL 字段值可以为空，设置的时候可以省略 NOT NULL 字段值禁止为空 自动编号 自动编号，必须与主键结合使用 默认情况下，起始值为1，每次的增量为1 主键约束 一张数据表中只能存在一个主键 主键保证记录的唯一性 主键自动为NOT NULL 1234567CREATE TABLE tb3( id SMALLINT UNSIGHED AUTO_INCREMENT PRIMARY KEY, username VARCHAR(20) NOT NULL);SHOW COLUMNS FROM tb3;INSERT tb3(username) VALUES('Kira');SELECT * FROM tb3; 唯一约束 唯一约束可以保证记录的唯一性 唯一约束的字段可以为空值（NULL） 每张数据表可以存在多个唯一约束 默认约束 当插入记录时，如果未明确为字段赋值，则会赋予默认值 12345678CREATE TABLE tb4( id SMALLINT NOT NULL AUTO_INCREMENT PRIMARY KEY, username VARCHAR(20) NOT NULL UNIQUE KEY, sex ENUM('1', '2', '3') DEFAULT '3');SHOW COLUMNS FROM tb4;INSERT tb6(username, sex) VALUES('Tom', 1);INSERT tb6(username) VALUES('Rose'); 再谈约束 约束保证数据的完整性和一致性 约束分为表级约束和列级约束，如果约束只针对某一个字段来约束，我们称之为列级约束，如果针对两个或两个以上字段来使用约束，则成为表级约束 约束类型包括（按功能分类） NOT NULL (非空约束) PRIMARY KEY(主键约束) UNIQUE KEY(唯一约束) DEFAULT(默认约束) FOREIGN KEY(外键约束) 外键约束 保持数据完整性和一致性 实现一对一或一对多的关系 外键约束要求 父表和子表必须使用相同的存储引擎，而且禁止使用临时表 数据表的存储引擎只能为InnoDB 外键列和参照列必须具有相似的数据类型。其中数字的长度或是是否有符号位必须相同，而字符长度则可以不同 外键列和参照列必须创建索引。如果外键列不存在索引的话，MySQL将会自动创建索引 PS : 子表是具有外键列的表，而子表所参照的表叫父表 外键列是加过FOREIGN关键字的列，而参照列则是外键列参照的列 编辑数据表的默认存储引擎 MySQL配置文件my.ini,修改完需重启MySQL服务 1default-storage-engine=INNODB 外键约束示例 省份表 12345CREATE TABLE provinces( id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, pname VARCAHR(20) NOT NULL);SHOW CREATE TABLE provinces; 用户表,pid参照省份表（父表）的id字段 123456CREATE TABLE users( id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, username VARCHAR(10) NOT NULL, pid BIGINT, FOREIGN KEY (pid) REFERENCES provinces (id) ); 上述操作会报错，因为父表的id与子表的pid数据类型不相似 修正后 123456CREATE TABLE users( id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, username VARCHAR(10) NOT NULL, pid SMALLINT UNSIGNED, FOREIGN KEY (pid) REFERENCES provinces(id) ); 外键约束的参照操作 这些操作是指在进行外键约束的情况下，在更新表的时候，子表是否也进行相应的操作 CASCADE 父表更新或删除行，也会更新或删除子表中匹配的行。而且插入数据时必须先在父表中插入，然后才能在子表中插入，原因是子表是参照父表的信息，如果没有父表信息，将导致子表无法参照 12345678910111213141516171819202122232425CREATE TABLE users1( id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, username VARCHAR(20) NOT NULL, pid SMALLINT UNSIGNED, FOREIGN KEY (pid) REFERENCES provinces (id) ON DELETE CASCADE);SHOW CREATE TABLE users1;INSERT provinces(pname) VALUES('A');INSERT provinces(pname) VALUES('B');INSERT provinces(pname) VALUES('C');SELECT * FROM provinces;INSERT users1(username, pid) VALUES('Tom', 3);INSERT users1(username, pid) VALUES('John', 1);INSERT users1(username, pid) VALUES('Rose', 3);SELECT * FROM users1;DELETE FROM provinces WHERE id = 3;SELECT * FROM provinces;SELECT * FROM users1; SET NULL 父表删除和更新行时，会设置子表中的外键列为NULL，但是必须在子表外键列没有设置NOT NULL的情况下 RESTRICT 拒绝对父表进行删除和更新操作 NO ACTION 与RESTRICT相同 在实际操作中，很少使用物理外键约束操作，而使用逻辑外键约束操作，原因是物理外键约束只有INNODB引擎才支持，逻辑外键就是我们在定义两张表的结构的时候，我们是按照存在着某种结构的方式去定义，但是不去使用FOREIGN KEY这个关键词来定义 表级约束与列级约束 如果按照功能划分会有主键约束，非空约束，唯一约束。而如果按照参照操作数目的多少来划分，则有表级和列级约束 列级约束 对一个列创建的约束，既可以在列定义时声明，也可以在列定义后声明 表级约束 对多个列创建的约束，只可以在列定义后声明 修改数据表 数据表的修改无非就是列的增加，列的删除，约束的添加，约束的删除等等一些操作 添加单列 12345SHOW COLUMNS FROM users1;ALTER TABLE users1 ADD age TINYINT UNSIGNED NOT NULL DEFAULT 10;ALTER TABLE users1 ADD password VARCHAR(32) NOT NULL AFTER username;ALTER TABLE users1 ADD realname VARCHAR(20) NOT NULL FIRST; 添加多列 与上面的语法相似，在ADD后面加上括号，不能指定位置关系（FIRST,AFTER） 删除列 12345ALTER TABLE users1 DROP realname;SHOW COLUMNS FROM users1;ALTER TABLE users1 DROP username, DROP age; 添加主键约束(默认B tree索引) 123456789CREATE TABLE users2( username VARCHAR(10) NOT NULL, pid SMALLINT UNSIGNED);SHOW CREATE TABLE users2;ALTER TABLE users2 ADD id SMALLINT UNSIGNED;ALTER TABLE users2 ADD CONSTRAINT PK_users2_id PRIMARY KEY (id); 添加唯一约束 1ALTER TABLE users2 ADD UNIQUE username; 添加外键约束 1ALTER TABLE users2 ADD FOREIGN KEY (pid) REFERENCES provinces (id); 添加或删除默认约束 123ALTER TABLE users2 ADD age SMALLINT UNSIGNED NOT NULL;ALTER TABLE users2 ALTER age SET DEFAULT 15;ALTER TABLE users2 ALTER age DROP DEFAULT; 删除主键约束 1ALTER TABLE users2 DROP PRIMARY KEY; 删除唯一约束 \\G指以网格方式呈现 12SHOW INDEXES FROM users2\\G;ALTER TABLE users2 DROP INDEX username; 删除外键约束 12SHOW CREATE TABLE users2;ALTER TABLE users2 DROP FOREIGN KEY users2_ibfk_1; 修改列定义 位置或列的类型有问题，是可以修改的,由大类型修改到小类型可能造成数据丢失 12ALTER TABLE users2 MODIFY id SMALLINT UNSIGNED NOT NULL FIRST;SHOW COLUMNS FROM users2; 修改列名称 既可以修改到列名称又可以修改到列定义 12ALTER TABLE users2 CHANGE pid p_id TINYINT UNSIGNED NOT NULL;SHOW COLUMNS FROM users2; 修改数据表名称123ALTER TABLE users2 RENAME users3;RENAME TABLE users3 to users2; 操作数据表中的记录插入记录1234567891011CREATE TABLE users( id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT, username VARCHAR(20) NOT NULL, password VARCHAR(32) NOT NULL, age TINYINT UNSIGNED NOT NULL DEFAULT 10, sex BOOLEAN );INSERT users VALUES(NULL, 'Tom', '123456', 15, 1);INSERT users VALUES(DEFAULT, 'John', '321', 15, 1);INSERT users SET username='Ben', password='456'; 更新记录（单表更新）123UPDATE users SET age = age + 5;UPDATE users SET age = age - id, sex = 0; UPDATE users SET age = age + 10 WHERE id % 2 = 0; 删除记录（单表删除）1DELETE FROM users WHERE id = 6; 查询记录1234SELECT id, username FROM users;SELECT username, id FROM users;SELECT users.id, users.username FROM users;SELECT id AS userId, username AS uname FROM users; ( 未完待续)","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"css可以继承的属性","slug":"css可以继承的属性","date":"2018-04-03T22:16:29.000Z","updated":"2018-04-03T22:43:32.278Z","comments":true,"path":"2018/04/04/css可以继承的属性/","link":"","permalink":"http://yoursite.com/2018/04/04/css可以继承的属性/","excerpt":"","text":"font-size text-indent text-align line-height word-spacing letter-spacing text-transform color visibility cursor direction font font-family font-style font-weight list-style ———————————————— 不常用 —————————————————– caption-side font-variant list-style-position list-style-type border-collapse border-spacing empty-cells table-layout list-style-type list-style-image quotes page page-break-inside widows orphans speak speak-punctuation speak-numeral speak-header speech-rate volume voice-family pitch pitch-range stress richness azimuth ​","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"不要做一个初级工程师（译）","slug":"不要做一个初级工程师（译）","date":"2018-03-24T00:35:12.000Z","updated":"2018-03-24T02:22:53.415Z","comments":true,"path":"2018/03/24/不要做一个初级工程师（译）/","link":"","permalink":"http://yoursite.com/2018/03/24/不要做一个初级工程师（译）/","excerpt":"","text":"本文由林子翔翻译于原文链接 严肃地说，不要做一个初级工程师。一个初级工程师，把这个头衔放到他简历，邮箱和其他社交信息里，把它告诉世界。不要这样！ 当你这样做了，人事和公司会这样看 你好，我拼命想成为你们公司的一名开发者。我还是个新手，但是请你请你请你请请你在我身上赌一把而且希望我能够成为公司的一笔财富而不是债务，而且我在前6个月还需要其他同事的帮助。。。 但是你说你就是一个初级工程师。这样的话，如果你专注于提高自己的技能去成为中级工程师会获得长远的成功，只有这样你才应该去申请一个工作。当你奉献你全部的时间去学习合理的技能，这时，你并不用把自己归为一个初级工程师这个品牌。记住，第一印象是很重要的，通过被录用为初级工程师，你将花费很长一段时间来摆脱这个头衔。如果你花一段时间去适应中级这个头衔，你将很快被录用为一个中级工程师。 但是你会问，什么时候你才知道自己不是一个中级工程师呢？你将永远不会知道。你将总是觉得自己知道得不够多，你将总是觉得其他人比你聪明，这被称作冒充者综合症。这很正常，大部分开发者都会有这个症状。但是这里有一个小的测试针对网站开发者：你能清晰地给家人介绍Internet怎样工作？电脑怎么工作？网站怎么工作？是否对HTML,CSS,JavaScript有基础的认识而能够做一个网站？知道一点React吗？能够通过github做几个项目并不费力地发布到线上？如果以上你都能做到，很好，你不是一个初级的工程师。 但是，你说你现在就需要一个工作。停止这个不长远的想法。除非你的工作是被一群特别优秀一批人所围绕然后可以每天从他们那里学习到东西，而且是最新的相关技术。你的时间将会投资到学习技能去摆脱初级头衔。长远的来看，可能你会得到更多的钱、处在一个更好的团队、而且你将更可能去为一个可以教你和使用前沿技术的公司每天工作。不要做一个常驻的法律公司开发者，去做什么WordPress插件这种。那将不会长远的帮助你。 注：这篇文章有点广告性质，所以只翻译了核心观点，作为一个开发者可以参考一下他的观点，个人觉得自己也有冒充者综合症，对该作者的大部分的观点是比较赞成的，但是我觉得有时候找工作涉及到的因素很多，这里有点片面，但不失为一篇不错的文章。这个冒充者综合症乃是直译，欢迎围观者提出更准确的翻译。","categories":[],"tags":[{"name":"翻译","slug":"翻译","permalink":"http://yoursite.com/tags/翻译/"}]},{"title":"Router进行代码分片","slug":"使用React和React Router进行代码分片","date":"2018-03-19T00:58:50.000Z","updated":"2018-03-19T12:02:40.470Z","comments":true,"path":"2018/03/19/使用React和React Router进行代码分片/","link":"","permalink":"http://yoursite.com/2018/03/19/使用React和React Router进行代码分片/","excerpt":"","text":"使用React和React Router进行代码分片 本文由林子翔翻译自原文链接 代码分片可以让你把应用分成多个包，使你的用户能逐步加载应用而变得流行起来。在这篇文章中，我们将会看一下什么是代码分片和怎么去做，了解怎么去配合React Router去实现它。 现在是2018年。你的用户不需要为了一小块内容而去下载整个应用。如果一个用户下载所有的代码，仅仅是为了请求一个注册页面是毫无意义的。而且用户在注册时并不需要下载用户设置页的巨大富文本编辑器代码。如果要下载那么多内容的话，是很浪费的。而且对于一些用户，他们会抱怨不尊重没有特别好带宽的他们。这个点子近年不仅很热，而且实现难度以指数级降低。甚至还有有了一个很酷的名字，代码分片。 这个点子很简单，即按需加载。实践的话，它可能有一点复杂。而复杂的原因并不是代码分片本身，而是现在有各种各样的工具来做这个事情。而且每个人对哪个方式最好都有自己的看法。当你第一次开始着手的时候，可能很困难分析什么是什么。 最常见的两种做法是使用Webpack和它的包加载器（bundle-loader），或者使用ECMAScript的stage3提案的动态import()。任何机会不用Webpack，我就不用，因此在这篇文章中，我将会使用动态import()。 如果你很熟悉ES模块，你应该知道它们是静态的。意思就是说你必须在编译时确定你要引入和导出的内容，而不是运行时。这也意味着你不能基于一些条件来动态导入一个模块。导入的内容必须声明在文件的最开头否则会抛出一个错误。 123if (!user) &#123; import * as api from './api' //不能这样做，“import”和“export”只能出现在文件顶部&#125; 现在，如果import不需要是静态的怎么办？意味着上面的代码可以工作?将会给我们带来什么好处？首先这意味着我可以按着需要加载某个模块。这非常强大，它让我们更接近按用户需要下载代码的想象。 12345if (editPost === true) &#123; import * as edit from './editpost' edit.showEditor()&#125; 假设editpost包含一个非常大的富文本编辑器，我们需要保证用户在没有使用它的时候不会去下载它。 另外一个很酷的例子用于遗留支持。你可以在浏览器确定确实没有的时候才下载对应代码。 好消息（我在上文中曾间接提及）。这种类型的方法确实存在，它被Create React App（React项目的一种官方创建方法）支持,而且它是ECMAScript stage3的提案。不同的是替换了你之前使用import的方式。它使用起来像一个方法，并返回一个Promise，一旦模块完全加载，就会把这个模块resolve回来。 12345if (editPost === true) &#123; import('./editpost') .then(module =&gt; module.showEditor()) .catch(e =&gt;)&#125; 特别好，对吧？ 现在我们知道怎么动态引入模块了，下一步是找出怎么结合React和React Router来使用它。 第一个（可能是最大的一个）问题，我们对React代码分片时，我们应该对哪里进行分片？典型的回答有两个 在路由的层次上分片 在组件的层次上分片 而更加常见的做法是在路由的层次上进行分片。你已经把你的应用分成了不同的路由，因此根据这个来代码分片是自然而然的事情。 让我以一个简单的React Router例子开始。我们将有三条路由分别是： /，/topics，/settings。 12345678910111213141516171819202122232425262728293031323334import React, &#123; Component &#125; from 'react'import &#123; BrowserRouter as Router, Route, Link,&#125; from 'react-router-dom'import Home from './Home'import Topics from './Topics'import Settings from './Settings'class App extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to='/'&gt;Home&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to='/topics'&gt;Topics&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to='/settings'&gt;Settings&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &lt;Route exact path='/' component=&#123;Home&#125; /&gt; &lt;Route exact path='/topics' component=&#123;Topics&#125; /&gt; &lt;Route exact path='/settings' component=&#123;Settings&#125; /&gt; &lt;/div&gt; &lt;/Router&gt; ) &#125;&#125;export default App 现在，假设我们的/settings路由内容非常多。它包含一个富文本编辑器，和一个原始超级马里奥兄弟的拷贝，和盖伊法利的高清图片。当用户不在/settings路由上时，我们不想让他们下载全部这些内容。让我们使用我们React和动态引入（import()）的知识来分片/settings路由。 就像我们在React里解决任何问题一样，我们先写一个组件。我们将叫它DynamicImport。这个组件的目的是动态的加载一个模块，只要模块加载好了，就把它传给它子节点（children）。 1234567const Settings = (props) =&gt; ( &lt;DynamicImport load=&#123;() =&gt; import('./Settings')&#125;&gt; &#123;(Component) =&gt; Component === null ? &lt;Loading /&gt; : &lt;Component &#123;...props&#125; /&gt;&#125; &lt;/DynamicImport&gt;) 上面的代码告诉我们两个重要的要素。第一，这个组件在执行时会接受一个属性load，将使用我们前面提到的语法动态引入一个模块。第二，这个组件会接受一个函数作为他的子节点，这个函数需要和引入进来的模块一起调用。 在我们深入思考DynamicImport的实现的之前，让我们想一下我们会怎么实现。第一件事我们需要确定的是要调用props.load。这让我们返回一个Promise，当它resolve的时候应该返回模块。接着，一旦我们有了模块，我们需要一种方式去触发重渲染，因此我们要把模块传给props.children并且调用它。怎样在React里面触发重渲染呢？设置state（setState）。通过把动态引入的模块加入到DynamicImport的state里面，就像我们之前使用的一样，我们遵循和React同样的过程- 获取数据 -&gt; 设置到state里 -&gt; 重渲染。而这一次我们只是把获取数据替换成了引入模块。 好了，首先，让我们加入初始的状态到组件里。 12345class DynamicImport extends Component &#123; state = &#123; component: null &#125;&#125; 现在，我们需要调props.load方法。这将返回一个promise同时在resolve后有一个模块 12345678910111213class DynamicImport extends Component &#123; state = &#123; component: null &#125; componentWillMount () &#123; this.props.load() .then(component =&gt; &#123; this.setState(() =&gt;｛ component )&#125; &#125;) &#125;&#125; 这里有一个疑难杂症。如果我们ES模块和commonjs模块混用时，ES模块会有一个.default属性，而commonjs模块并没有。让我们改变一下代码，适应一下上面的情况。 12345678this.props.load() .then(component =&gt; &#123; this.setState(() =&gt; &#123; component: component.default ?component.default : component &#125;) &#125;)&#125;) 现在我们动态引入的模块并且把它加入到了state里面，最后一件事就是render方法长什么样了。如果你会记得，当DynamicImport使用的时候，它看起来像这样 1234567const Settings = (props) =&gt; ( &lt;DynamicImport load=&#123;() =&gt; import('./Settings')&#125;&gt; &#123;(Component) =&gt; Component === null ? ＜Loading/&gt; : &lt;Component &#123;...props&#125; /&gt;&#125; &lt;/DynamicImport&gt;) 注意我们给组件传了一个函数作为子节点。这意味着我们需要执行这个函数，传递的是这个引入在state里的组件。 123456789101112131415161718class DynamicImport extends Component &#123; state = &#123; component: null &#125; componentWillMount () &#123; this.props.load() .then((component) =&gt; &#123; this.setState(&#123; component: component.default ? component.default : component &#125;) &#125;) &#125; render() &#123; return this.props.children(this.state.component) &#125;&#125; 欧了，现在任何时候我们动态引入一个模块，我们可以把它包裹在DynamicImport。如果我们之前尝试用这种方法到我们路由上，我们的代码会看起来像这样 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import React, &#123; Component &#125; from 'react'import &#123; BrowserRouter as Router, Route, Link&#125; from 'react-router-dom'class DynamicImport extends Component &#123; state = &#123; component: null &#125; componentWillMount () &#123; this.props.load() .then((component) =&gt; &#123; this.setState(&#123; component: component.default ? component.default : component &#125;) &#125;) &#125; render() &#123; return this.props.children(this.state.component) &#125;&#125;const Home = (props) =&gt; ( &lt;DynamicImport load=&#123;() =&gt; import('./Home')&#125;&gt; &#123;(Component) =&gt; Component === null ? &lt;p&gt;Loading&lt;/p&gt; : &lt;Component &#123;...props&#125; /&gt; &#125; &lt;/DynamicImport&gt;)const Topics = (props) =&gt; ( &lt;DynamicImport load=&#123;() =&gt; import('./Settings')&#125;&gt; &#123;(Component) =&gt; Component === null ? &lt;p&gt;Loading&lt;/p&gt; : &lt;Component &#123;...props&#125;/&gt; &#125; &lt;/DynamicImport&gt;)class App extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to='/'&gt;Home&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to='/topics'&gt;Topics&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to='/settings'&gt;Settings&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &lt;Route exact path='/' component=&#123;Home&#125; /&gt; &lt;Route path='/topics' component=&#123;Topics&#125; /&gt; &lt;Route path='/settings' component=&#123;Settings&#125; /&gt; &lt;/div&gt; &lt;/Router&gt; ) &#125;&#125;export default App 我们怎么知道这个确实起作用并且分片了我们的路由呢？如果你用一个React官方的Create React App创建一个应用跑一下npm run build，你将看到应用被分片了。 每一个包被一一引入进了我们的应用 你到了这一步，可以跳个舞轻松一下了 还记得我讲到有两种层级的代码分片方式吗？我们曾放在手边的引导 以路由层级分片 以组建层级分片 至此，我们只讲了路由层级的代码分片。到这里很多人就停止了。在路由层级上代码分片，就像刷牙一样，你天天刷，牙齿大部分很干净，但是还会有蛀牙。 除了思考用路由的分片方式，你应该想想怎么用组件的方式去分片。如果你在弹层里面有很多内容，路由分片还是会下载弹层的代码，无论这个弹层是否显示。 从这一点看，它更多是在你大脑里的一种变更而不是新知识。你已经知道如何使用动态引入，现在你需要找出哪些组件是在用到时才要下载的。 如果我不提React Loadable那我就是哑巴了。它是一个“通过动态引入加载组件的高阶组件”。重要的是，它处理所有我们提到的事情，并把它做成了一个精致的API。它甚至处理了很多很边角的事情，比如我们没有考虑服务端渲染和错误处理。看看它吧，如果你想要一个简单，开箱即用的解决方案的话。 ​ (完，逃)","categories":[],"tags":[{"name":"翻译","slug":"翻译","permalink":"http://yoursite.com/tags/翻译/"}]},{"title":"wepy开发速查手册","slug":"wepy开发速查手册","date":"2018-03-11T08:25:24.000Z","updated":"2018-03-13T09:49:35.449Z","comments":true,"path":"2018/03/11/wepy开发速查手册/","link":"","permalink":"http://yoursite.com/2018/03/11/wepy开发速查手册/","excerpt":"","text":"事件bindtap=”click”替换为@tap=”click”,防止冒泡@tap.stop,防止捕获@tap.capture.stop，如果是@someEvent.user=”somefunction”，这种通过this.$emit(‘someEvent’),someFunction会触发而且写在父组件methods里面，同时父组件events里面的someEvent时不会执行 events示例 123456// events对象中所声明的函数为用于监听组件之间的通信与交互事件的事件处理函数 events = &#123; 'someEvent': (p1, p2, p3, $event) =&gt; &#123; console.log(`$&#123;this.$name&#125; receive $&#123;$event.name&#125; from $&#123;$event.source.$name&#125;`); &#125; &#125;; ​ 事件传参变更，bindtap=”click” data-index=”“更改为@tap=”click()” repeat使用实例 12345&lt;!-- 注意，使用for属性，而不是使用wx:for属性 --&gt;&lt;repeat for=\"&#123;&#123;list&#125;&#125;\" key=\"index\" index=\"index\" item=\"item\"&gt; &lt;!-- 插入&lt;script&gt;脚本部分所声明的child组件，同时传入item --&gt; &lt;child :item=\"item\"&gt;&lt;/child&gt;&lt;/repeat&gt; computed计算属性，只要是组件中有任何数据发生了改变，那么所有计算属性就都会被重新计算，代码中可通过this.计算属性名来引用，模板中也可通过来绑定数据 12345678910data = &#123; a: 1&#125;// 计算属性aPlus，在脚本中可通过this.aPlus来引用，在模板中可通过&#123;&#123; aPlus &#125;&#125;来插值computed = &#123; aPlus () &#123; return this.a + 1 &#125;&#125; ​ watcher监听器， 通过监听器watcher能够监听到任何属性的更新 1234567891011data = &#123; num: 1&#125;// 监听器函数名必须跟需要被监听的data对象中的属性num同名，// 其参数中的newValue为属性改变后的新值，oldValue为改变前的旧值watch = &#123; num (newValue, oldValue) &#123; console.log(`num value: $&#123;oldValue&#125; -&gt; $&#123;newValue&#125;`) &#125;&#125; 数据绑定使用:号比如，不使用冒号是绑定字符串常量，sync不加，父组件这个变量变化就不会影响子组件，加了sync，同时，写了twoWay: true时就是双向绑定，即同一个属性（props）的变化，父修改了影响子，子修改了影响父 1&lt;child :title=\"parentTitle\" :syncTitle.sync=\"parentTitle\" :twoWayTitle=\"parentTitle\"&gt;&lt;/child&gt; 12345678910111213141516props = &#123; // 静态传值 title: String, // 父向子单向动态传值 syncTitle: &#123; type: String, default: 'null' &#125;, //这里即twoWay twoWayTitle: &#123; type: Number, default: 'nothing', twoWay: true &#125;&#125;; 通信 父组件发起的：$broadcast（特性：所有子组件都会收到此广播事件，顺序由上至下，广度优先） 子组件发起的：$emit（特性：事件发起组件的所有祖先组件会依次接收到事件,顺序由下至上) 组件间发起的：$invoke (特性：一个页面或组件对另一个组件中的方法的直接调用) $invoke示例(这里能否用到alias路径，大家可以试试) 1this.$invoke('./../ComB/ComG', 'someMethod', 'someArgs'); 回调均在events对象里面写 wxs 123456789101112131415161718192021222324252627282930module.exports = &#123; text: &apos;This is from wxs&apos;, filter: function (num) &#123; return num.toFixed(2); &#125;&#125;;// index.wpy&lt;template&gt; &lt;text&gt;&#123;&#123;m1.text&#125;&#125;&lt;/text&gt; &lt;text&gt;&#123;&#123;m1.filter(num)&#125;&#125;&lt;/text&gt;&lt;/template&gt;&lt;script&gt; import wepy from &apos;wepy&apos;; import mywxs from &apos;../wxs/mywxs.wxs&apos;; export default class Index extends wepy.page &#123; data = &#123; num: 10 &#125;; wxs = &#123; m1: mywxs &#125; &#125;;&lt;/script&gt; ​","categories":[],"tags":[{"name":"wepy","slug":"wepy","permalink":"http://yoursite.com/tags/wepy/"}]},{"title":"微信小程序api之setEnableDebug说明","slug":"微信小程序api之setEnableDebug说明","date":"2018-03-04T07:20:01.000Z","updated":"2018-03-04T07:29:09.267Z","comments":true,"path":"2018/03/04/微信小程序api之setEnableDebug说明/","link":"","permalink":"http://yoursite.com/2018/03/04/微信小程序api之setEnableDebug说明/","excerpt":"","text":"使用方法1234567//app.jsonLaunch() &#123; //开启调试 wx.setEnableDebug(&#123; enableDebug: true &#125;)&#125; 解释 这个接口相当于是用代码来在预览时开启调试，预览后打开小程序后会提示“重新打开小程序后生效”，点击确定后，在微信-发现-小程序中打开小程序，此时右下角会出现一个绿色可拖动的vConsole，可以显示调试信息 另一种非代码开启方式是点击小程序右上角的胶囊中三个点符号，在这里点击打开调试，会和上面讲的一样，出现同样的过程 如果设置enableDebug为false，会同样出现上述过程的逆过程，是一样的道理","categories":[],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/微信小程序/"}]},{"title":"函数式编程入门","slug":"函数式编程入门","date":"2018-02-28T14:02:09.000Z","updated":"2018-03-04T05:24:43.172Z","comments":true,"path":"2018/02/28/函数式编程入门/","link":"","permalink":"http://yoursite.com/2018/02/28/函数式编程入门/","excerpt":"","text":"什么是函数式编程函数式编程，个人理解是在编写纯函数。 据印度Anto Aravinth的解释的函数式编程是一种范式，我们能依靠这种范式创建仅依赖输入就可以完成自身逻辑的函数。 而这种函数就是我所理解的纯函数。 纯函数特点 同样的输入，输出一定相同 函数不会改变任何外部环境的变量 函数式编程的引用透明性 即所有函数对于相同输入都返回相同的值，那么据此产生了一个术语，叫替换模型，即把一个函数的调用用它的返回值替换，这将带来可以缓存的代码，当函数调用以后，我们将它的返回值存在内存里（比如用一个对象的属性存起来），下次使用就直接取对象这个属性映射的值。 并发优势 在并发层面上，由于函数不会对外部环境变量进行修改，只依赖传入的参数，所以，并发执行两个或多个一样的函数时相互之间不会受到影响 抽象与高阶函数抽象 个人总结维基百科的表述，抽象即是一种管理复杂度的方法，把复杂度限定到你能处理的范围。这个范围层面的确定即是一种抽象。 比如高级程序语言就是一种抽象，它的底层是复杂的汇编语言以及机器语言，然而你把它抽象出来进行问题的处理，而不考虑底层复杂的调用和实现 抽象使我们关注预定的目标而不去考虑底层的细节实现 高阶函数 高阶函数就是接受函数作为参数并且/或者返回函数作为输出的函数 经常用到的比如map，forEach等 高阶函数的思维 高阶函数是一种声明式的抽象，声明式即研究“做什么”而不是“如何做”，而抽象使问题关注的地方更加单一，简单化 比如forEach函数抽象出了遍历数组这个过程，我们不用去关心如何去做遍历，而是专注于对每次遍历的结果的操作 柯里化一元函数与多元函数 只接受一个参数的函数叫一元函数，可以以此类推，几元函数就是接受几个参数的函数 变参函数 函数接受的参数不确定的函数叫做变参函数（比如使用arguments） 1234567/** * 变参函数 */function vary(...args) &#123; console.log(args) //do something to args&#125; 柯里化思想 所谓柯里化就是把多参函数转化为嵌套的单参函数 currying的一种实现1234567891011121314151617181920/** * 将多参函数转换为单参函数的一种实现 * @params fn 需要转化的多参函数 */function curry(fn) &#123; //异常处理 if (typeof fn !== 'function') &#123; throw new Error('fn is not a function') &#125; //转换处理 return function curryInner(...args) =&gt; &#123; //当传入函数的参数数目大于返回curryInner的参数长度时 if (fn.length &gt; args.length)&#123; return function() &#123; return curryInner.apply(null, args.concat([].slice.call(arguments))) &#125; &#125; return fn.apply(null, args); &#125;&#125; 分析举例1234567891011121314151617181920212223/** * 测试函数作为实参传递 * @params x, y, z */function foo(x, y, z) &#123; // do something&#125;const curriedFn = curry(foo);/** * 此时curriedFn为 * function curryInner(...args) =&gt; &#123; * if (fn.length &gt; args.length)&#123; * return function() &#123; * return curryInner.apply(null, args.concat([].slice.call(arguments))) * &#125; * &#125; * return fn.apply(null, args) * &#125; *///调用并传入实参1, 2 ,3curriedFn(1)(2)(3) 当执行到curriedFn(1)时，因为args.length为1，fn.length为3所以进入if块将args的参数连接，此时args.length为2 上一步返回的还是curryInner函数，再执行curriedFn(1)(2),此时由于args.length为2还是小于3，再重复上述步骤执行curriedFn(1)(2)(3) 此时args.length为3，if条件不满足，执行fn.apply(null, args),即相当于执行了foo(1,2,3) 文献参考：《JavaScript ES6 函数式编程入门经典》 【印】Anto Aravinth 著 梁宵 译","categories":[],"tags":[{"name":"心得体会","slug":"心得体会","permalink":"http://yoursite.com/tags/心得体会/"}]},{"title":"mark","slug":"mark","date":"2018-02-22T10:57:35.000Z","updated":"2018-02-22T11:04:42.194Z","comments":true,"path":"2018/02/22/mark/","link":"","permalink":"http://yoursite.com/2018/02/22/mark/","excerpt":"","text":"12345function test(a, b) &#123;&#125;function b(a, b) &#123; test(a, b)&#125; 1&lt;SomeComponent callback=&#123;(a, b) =&gt; &#123;this.test(a, b)&#125;&#125; /&gt; 12345function test(a, b) &#123;&#125;function b(test) &#123; test(a, b)&#125; 1&lt;SomeComponent callback=&#123;::this.test&#125; /&gt;","categories":[],"tags":[{"name":"记录","slug":"记录","permalink":"http://yoursite.com/tags/记录/"}]},{"title":"html5的data-*","slug":"html5的data","date":"2018-02-12T10:51:30.000Z","updated":"2018-02-12T11:06:00.261Z","comments":true,"path":"2018/02/12/html5的data/","link":"","permalink":"http://yoursite.com/2018/02/12/html5的data/","excerpt":"","text":"引入看公司的表单组件，发现一个data-name属性，这个在最早做react的todo时，遇到过，因为获取不到直接定义的属性，还写过一篇肤浅的博客。其实这个并不是react里面的内容，而是html5里面的 data-*用法目前我没有参考文档，所以不知道它为什么会出现，但是我知道怎么用，在什么场景用，直接讲自己理解的用法。 获取这个属性，可以利用 1domNode.getAttribute('data-foo') 这个其中一个应用场景就是你在react中获取节点后，想获取这个data-属性里面的值 还可以在事件对象的当前对象下的dataset属性中获取 1e.currentTarget.dataset.foo; 这个让我想到了小程序，它内部实现也估计用了这个。 延伸题外话html5很重要，很多东西经常用到，我们应该怎么学习html5，我的体会是从html5名字去搜书名得到的书是不行的。但是有一本书，我最近翻了翻，发现里面有很多html5的内容，那就是大家都知道的《JavaScript高级程序设计》，很厚，一天读10页，也要很久读完，推荐大家如果忙的话，把它当字典查，当然最好是读一遍。 我之前项目搜data-name没搜到，后来看了mdn以后，我说不可能搜不到，肯定是之前没搜好，果然就是我的想法，搜到了，也是上述用法用的。 REACT16以后可以不用data-*，不带data-的属性也会渲染到原生dom节点上了 更多内容待大家一起探讨，下次见","categories":[],"tags":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"}]},{"title":"聊聊webpack","slug":"聊聊webpack","date":"2018-02-10T10:04:19.000Z","updated":"2018-02-10T10:24:29.309Z","comments":true,"path":"2018/02/10/聊聊webpack/","link":"","permalink":"http://yoursite.com/2018/02/10/聊聊webpack/","excerpt":"","text":"原创申明 该空间内所有博客所有内容均为原创，由于是个人的理解，可能有所勘误，敬请指正 webpack个人对它的介绍 webpack会从一个文件或者多个文件开始，它里面的依赖的模块，会被以webpack的方式优雅的合成一个或多个bundle文件，这里是对js的构建，那么这时，你可以把它引用到html的script标签中。但是一般不是你手动引入，webpack可以帮你做到，用到的就是它的插件，包括css也是类似的道理，会被引到head的link标签里。 上述过程生成的东西会产生一个文件夹，这个文件夹你可以指定，这个文件夹包含了一套的前端所需要的东西，是什么呢？那就是现代浏览器可以执行的html，css，js。 为什么要加上现代浏览器可以执行的，因为这很重要，而且也因为我们写的代码都是浏览器不支持的，我们把这个文件夹的内容放到服务器上部署，就有一个前端的内容了。 为什么要写浏览器不支持的代码？其中很重要的一点，是程序员里面很常见的词汇，那就是优雅。对，这些代码很优雅，有很多语法糖。什么是语法糖，我个人理解，是通过约定把本来需要一大堆代码实现的东西变成简单的写法。这就很优雅，那么优雅是什么，优雅就是开发效率，与开发时的快感的增加。 webpack有很多东西在官网上浅尝则止，并没有说的很深入，如果想要深入可以阅读《深入浅出webpack》，我也在读，不过我经过搭了一个react react-router v4 按需加载的项目之后在读，体会更佳，欢迎加入。","categories":[],"tags":[{"name":"心得体会","slug":"心得体会","permalink":"http://yoursite.com/tags/心得体会/"}]},{"title":"日期+学习到的知识点","slug":"日期-学习到的知识点","date":"2018-01-30T13:26:20.000Z","updated":"2018-02-21T09:18:07.909Z","comments":true,"path":"2018/01/30/日期-学习到的知识点/","link":"","permalink":"http://yoursite.com/2018/01/30/日期-学习到的知识点/","excerpt":"","text":"2018-1-30 css filter: drop-shadow() sass draken() sass placeholder sass @include sass @content redux mapDispatchToProps dispatched function(bindActionCreator) react-router onEnter hook(20%) react-router IndexRoute IndexRedirect 高阶函数例子及定义 2018-2-13 understand es7 function bind syntax in react review this in ecmascript 2018-2-17 currentTarget &lt;- represent registered element and equal to this in event handler target &lt;- actual and real target in event understand function parameters transfer by value 2018-2-21 scope chain and excution context environment reference counting strategy of garbage collection","categories":[],"tags":[{"name":"学习记录","slug":"学习记录","permalink":"http://yoursite.com/tags/学习记录/"}]},{"title":"陪自己走过白天黑夜","slug":"陪自己走过白天黑夜","date":"2018-01-25T05:13:15.000Z","updated":"2018-01-25T05:48:51.062Z","comments":true,"path":"2018/01/25/陪自己走过白天黑夜/","link":"","permalink":"http://yoursite.com/2018/01/25/陪自己走过白天黑夜/","excerpt":"","text":"cnode论坛好像是狼叔建的，一个很有趣的地方，一个卧虎藏龙的地方。 比如昨天，我在上面发现了一位我很欣赏的前辈，他叫邹业盛。起初并不认识他，我只是在cnode上面瞎逛，把一些有可能会用到帖子打开，寻找一点营养吸收一下，我在几篇可能出现干货的帖子下发现了一个人，他把问题分析得极其透彻，就是用自己的话说出来的那种，而且一看就是踩过了那些坑并有很深体会的人。我顿时在github中寻找他，还真给我找到，于是进入到他的博客里面，文章都很朴实，满满干货，还带个人体会，读完收获不小。今天仔细看他的title，原来是阿里的。 记得狼叔曾经开个一个玩笑，所有的前端程序员的归宿不是阿里就是在去阿里的路上。确实从侧面也反映了一个问题，就是阿里的员工真的很优秀。我目前网上见到的阿里的人都是很全面的人。强到可怕，普通公司的人跟阿里的一比，差距就是十万八千里，不过也夸张了一点，只是想说，他们很强。 昨天我问同事，我说你的职业规划是怎样的，他说估计以后是往管理或者创业发展。我又问其他同事，答案也差不多。我总结一下，他们的看法是35岁要做成管理或者架构师。对我来说还有10年，10年是很长的。如果这10年，每日精进，他们的想法都是可以实现的。也有很多这样的人，他们只花了几年。 链家的鸟哥说要脱离自己的舒适区，上面说的其实就要做到鸟叔说的那样才好实现。如果停留在自己的舒适区，就是网上流行的1年经验重复3年。我想的是，劳逸结合，带点紧迫感的顺其自然，这样比较适合我这种人，有松有紧。 以前迷吉他指弹的时候，老是看日本押尾桑的视频，他说学习的时候跟吉他老师交流，与同学交流进步更快，也更有乐趣。这里有两个关键词，进步和乐趣，这两点相辅相成。虽然已经工作了，我也类似的报了一个班，接触了一些朋友和老师，老师都是阿里或者一些知名公司的。于是就有了一个氛围，是在线的。我一般是看录播，因为平时都在加班。看过一遍，老师说的话对我很有指导作用。了解一些骚操作。偶尔会在群里问一下node的问题，除了node问题的基本不会问。问也是问一些通用的解决方案，也就是套路。当然我还问过狼叔，狼叔人很好的，回答也很赞。所以我学习有很多途径，一方面自己看书看博客文章，二方面工作积累用博客记录，三方面各种我自己营造的氛围，比如知识星球，微信群，qq群，报的班的资料，四方面向高手请教，论坛提问。 我的博客技术为主，辅助一些自己个人随笔，蝼蚁之词，见笑了。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"解决小程序音频自定义组件不同时播放问题","slug":"解决小程序音频自定义组件不同时播放问题","date":"2018-01-24T16:22:07.000Z","updated":"2018-03-11T08:23:05.004Z","comments":true,"path":"2018/01/25/解决小程序音频自定义组件不同时播放问题/","link":"","permalink":"http://yoursite.com/2018/01/25/解决小程序音频自定义组件不同时播放问题/","excerpt":"","text":"需求首先是一个播放的气泡，点击播放src音频，但是是一组列表，有许多这样的气泡，点其中一个播放后，再点其他的，前一个要停止播放。 分析这种其实是很好实现的，如果是直接写的话。但是现在用上了小程序的自定义组件，每个组件都是独立的没有联系，唯一的联系是父组件，这个时候，我们该怎么办呢。 解决方案由于涉及保密协议，就不上代码，说说思路。 思路： 用广播，如果该组件播放时，就发出一个广播，让其他组件关闭播放。 这里知识用到观察者模式（订阅与发布），具体怎么实现，有很多方式，本项目中的实现是我的师父写的，然而他写的有个地方有问题，他用了Promise处理监听的回调，然而Promise resolve以后，它的生命就到此为止了（个人目前的理解是这样的，如有勘误，请务必指出），所以只能执行一次回调，而不能多次监听，触发回调。我把这里改了，实现了一次监听，有触发随时执行。 关键问题，我怎么样只广播非当前播放的气泡呢。设一个属性，每次给一个变化的值进去，利用observer确定是当前组件，当前组件执行一个逻辑，这个逻辑就是避免被广播到 总结程序出不来，大部分是代码原因，继续搞，继续搞就能看到光明。 我的每篇文章都不长，但都可以说明一个问题，欢迎阅读。 -————–update分割线 —————– 最佳实践是这样的： 前端工作遇到的小知识点第14点，最好放在父组件中控制，上面操作太骚，而且后期处理起来不易维护","categories":[],"tags":[{"name":"工作经验","slug":"工作经验","permalink":"http://yoursite.com/tags/工作经验/"}]},{"title":"带着如何开放不使用jwt路由而阅读koa-jwt源码引出对koa-unless的阅读","slug":"带着如何开放不使用jwt路由而阅读koa-jwt源码引出对koa-unless的阅读","date":"2018-01-21T05:24:01.000Z","updated":"2018-01-21T06:08:37.784Z","comments":true,"path":"2018/01/21/带着如何开放不使用jwt路由而阅读koa-jwt源码引出对koa-unless的阅读/","link":"","permalink":"http://yoursite.com/2018/01/21/带着如何开放不使用jwt路由而阅读koa-jwt源码引出对koa-unless的阅读/","excerpt":"","text":"问题引入想往项目里面加入401状态，而考虑使用比较公认的jwt技术，遇到一个问题，就是如何开放一些不需要token的路由？ 尝试获取资料于是寻找github上面一些使用jwt验证的项目阅读其中的源码，然而发现都不是自己原生使用jsonwebtoken而是用的express-jwt和koa-jwt，而这两个库都有我尝试解决的问题的解决方案，于是我找到koa-jwt的源码，发现里面使用了koa-unless库，这个库是干嘛的呢，实际是让你指定的路由跳过当前的中间件，那么看看源码。 阅读koa-unless源码1234567891011121314151617181920/** Creates a wrapper middleware that verifies if the original middleware should be skipped. */module.exports = function(options) &#123; var originalMiddleware = this; // If a custom function was passed directly, creates a new object literal that holds it as a property called custom. var opts = typeof options === 'function' ? &#123; custom: options &#125; : options; // Returns the middleware that wraps the original one. return function *(next) &#123; var requestedUrl = url.parse((opts.useOriginalUrl ? this.originalUrl : this.url) || '', true); // any match means 'skip original middleware' if (matchesCustom(this, opts) || matchesPath(requestedUrl, opts) || matchesExtension(requestedUrl, opts) || matchesMethod(this.method, opts)) &#123; return yield *next; &#125; yield *originalMiddleware.call(this, next); &#125;;&#125;; 关键地方 12var originalMiddleware = this;//这里获取当前要跳过的中间件实例 1234if (matchesCustom(this, opts) || matchesPath(requestedUrl, opts) || matchesExtension(requestedUrl, opts) || matchesMethod(this.method, opts)) &#123; return yield *next; //这里判断参数匹配的话，就把控制权转移下个中间件，从而跳过该中间件 &#125; 12yield *originalMiddleware.call(this, next);//这一句结合上面一句来看就是参数不匹配就执行当前中间件 总结总的思路是不执行jwt的验证的中间件，思路其实也很直接，那我就愉快的借用一下罗。~_~! ps国外源码注释真的很清晰，其实在工作中应该也效仿。","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"node流程控制之串行","slug":"node流程控制之串行","date":"2018-01-18T10:22:28.000Z","updated":"2018-01-18T10:33:02.050Z","comments":true,"path":"2018/01/18/node流程控制之串行/","link":"","permalink":"http://yoursite.com/2018/01/18/node流程控制之串行/","excerpt":"","text":"1234567891011121314151617181920212223242526272829function process1() &#123; setTimeout(function() &#123; var process1Result = 1; next(null, process1Result) &#125;,10)&#125;function process2(data) &#123; setTimeout(function() &#123; if (data === 1) var process2Result = 2; next(null, process2Result) &#125;)&#125;function process3(data) &#123; console.log(data);&#125;var taskList = [ process1, process2, process3]next(err, result) &#123; if (err) throw err; var current = taskList.shift(); current &amp;&amp; current(result);&#125;next(); 流程控制 在node中让一组异步操作顺序执行的套路叫做流程控制，而这其中又分为串行流程和并行流程 串行流程 所谓串行流程，即一个接着一个做的流程叫做串行流程，上述代码即一个串行流程的实现。 首先有三个操作，顺序依次为process1，process2，process3， 整个过程的核心是这个next函数，跟node一些框架中交出控制权的next名字是一样的 思路就是按照索引的顺序执行函数，函数中异步调用的返回值，作为下一个next中执行的函数的参数，保证了数据不会丢失。","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"Node编程基础","slug":"Node编程基础","date":"2018-01-11T05:59:29.000Z","updated":"2018-01-11T06:00:40.275Z","comments":true,"path":"2018/01/11/Node编程基础/","link":"","permalink":"http://yoursite.com/2018/01/11/Node编程基础/","excerpt":"","text":"Node编程基础如何组织代码 模块是Node让代码易于重用的一种组织和包装方式 传统方式按逻辑把单个文件分为多个文件，但这些文件互相引用的同时会产生全局变量污染的问题 Node模块打包代码是为了重用，但它们不会改变全局作用域 Node模块允许你从被引入文件中选择要你暴露给程序的函数和变量，如果模块返回的函数和变量不止一个，可以把它们作为exports对象的属性，否则就使用module.exports 如何创建模块 模块既可能是一个文件，也可能是包含一个或多个文件的目录。如果模块是一个目录，Node通常会在这个目录下找一个叫index.js的文件作为模块的入口 使用模块要用到require函数，require是Node中少数几个同步I/O操作之一 用node_modules重用模块 要求模块在文件系统中使用相对路径存放，对于组织程序特定的代码很有帮助，但是与他人共享代码却用处不大。Node的node_modules机制可以不必知道模块在文件系统中的具体位置。 node_modules的搜寻机制如下： 1.开始在文件同一目录下寻找； 2.没有找到，就在当前目录node_modules下找 3.没有找到，进入父目录，再找当前目录node_modules中有没有，重复3； 4.没有找到，找环境变量NODE_PATH指定目录中是否存在； 5没有找到，异常。 异步编程技术 事件发生会触发响应逻辑。 在Node事件里流行两种响应逻辑的管理方式： 回调 回调通常用来定义一次性响应逻辑。比如数据库查询，可以指定一个回调函数来确定如何处理查询结果。这个回调函数可能会显示数据数据库查询结果，根据这些结果做些计算，或者以查询结果为参数执行另一个回调函数 事件监听 事件监听器，本质上也是一个回调，不同的是，它跟一个事件相关联。在Node中，当有HTTP请求过来时，此时服务器会产生一个事件，事件监听器就可以监听这个事件，并添加一些响应的逻辑。 一个Node HTTP服务器实例就是一个事件发射器 能够继承和添加事件发射及处理能力的类（EventEmitter） （未完待续）","categories":[],"tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"基本视觉格式化","slug":"基本视觉格式化","date":"2018-01-11T05:48:33.000Z","updated":"2018-01-16T05:27:23.091Z","comments":true,"path":"2018/01/11/基本视觉格式化/","link":"","permalink":"http://yoursite.com/2018/01/11/基本视觉格式化/","excerpt":"","text":"基本视觉格式化基本框 css假定每个元素都会生成一个或多个矩形框，这称为元素框。各元素框中心有一个内容区。这个内容区周围有可选的内边距，边框和外边距。 包含块（布局上下文） 每个元素都相对于其包含块摆放。正常流中的一个元素，其包含块由最近的块级祖先框、表单元格或行内块祖先框的内容边界构成。 正常流是指西方语言文本从左向右、从上向下显示。大多数元素都在正常流中，除了浮动或定位元素。 块级元素 一般一个基本框从左到右有这几个部分： 左外边界 左外边距 左边框 左内边距 左内边界 内容区宽度 右内边界 右内边距 右边框 右外边距 右外边界 一般地，一个元素的宽度（width）被定义为从左内边界到右内边界的距离，高度同理。高度和宽度属性都可以应用到元素。 不同的宽度、高度、内边距和外边距相结合，就可以确定文档的布局。 水平格式化 区分width和可见元素框的宽度，width属性是不包含padding和margin的（例外的是使用了CSS3的box-sizing），而可见元素框宽度是包含了padding和margin的 有个规则，正常流中块级元素框的水平部分总和就等于父元素width。这一句话即所有子元素的width加上它们的左、右内边距，边框和外边距就是父元素的width。 水平属性 水平格式化有7大属性，从左至右，分别是：margin-left, border-left,padding-left,width,padding-right,border-right,margin-right。这7个属性的值加在一起必须是元素包含块的宽度，这往往是块元素的的父元素的width。 这7大属性只有其中3个可以设置为auto（width，margin-left,margin-right） 使用auto（不考虑3个值以外的属性） 3个auto（margin-left,width,margin-right均为auto），其中width会占满父元素width，而margin-left,margin-right为0 2个auto（比如margin-left,width为auto），这时设置auto的属性会为0，width会将父元素width的剩余空间占满 1个auto，如果设置3个值其中一个为auto，那么设置auto的属性会确定所需的长度，保证3个值加起来等于父元素的width 0个auto同时三者设置的和超过父元素width，则margin-right会为auto。 （未完待续） 负外边距 外边距可以为负 7个水平属性总和要等于父元素的width，严格的说这个总和不能比包含块更宽。所以当外边距为负时子元素的width会超过父元素width，达到一种超出的效果 只要所有属性都是大于或等于0的，元素就不会大于父元素的内容区 百分数 值声明为长度还是百分数，并没有改变上述水平格式化规则","categories":[],"tags":[{"name":"css读书笔记","slug":"css读书笔记","permalink":"http://yoursite.com/tags/css读书笔记/"}]},{"title":"前端工作遇到的小知识点","slug":"前端工作遇到的小知识点","date":"2018-01-09T02:21:41.000Z","updated":"2018-04-29T22:09:24.701Z","comments":true,"path":"2018/01/09/前端工作遇到的小知识点/","link":"","permalink":"http://yoursite.com/2018/01/09/前端工作遇到的小知识点/","excerpt":"","text":"顶部子元素的margin-top直接到父元素上，目前简单的处理方法将子元素margin-top变成父元素padding-top,感觉其他方式也可以解决比如改变BFC，需要补一下BFC，还不太熟 微信小程序中，纵向的高度一定不要px，否则到不同屏幕上差异很明显，横向如果写滑动的效果，计算的left值可以用px，因为获取到的屏幕的宽度是一个以px为单位的值，用px才不会出现位置上偏移的问题。 文本溢出无法实现时，使用height,line-height,overflow做 做列表勾选同步时，前端修改了数据勾选状态，如果请求后端同步时失败，应回滚前端勾选状态，这中列表数据自带勾选状态的做法，也是一种性能优化的经验 接口全局配置，如果有两套环境（生产和测试），在页面里用到相关接口url，必须通过配置文件来引用，而不是直接写，如果有不同，就切分字符串，不然你绝对会不停的改来改去。 原生小程序，setData方法绝对不能set一个undefined值，否则真机会报一个null的错误，同时定位这种错误的方法是打console看这个null的log在console的前面还是后面来定位，巨坑哦 原生小程序组件在一个页面多次使用，并且要实现使用父组件的data作为组件的property，即在子组件要改变父组件data，来引起子组件properties变化，从而引起视图变化，达到一中父子组件通信的目的，可以充分使用triggerEvent方法，并且在触发时传入type字符串，以实现多态。 遇到一个问题，小程序在audio播放toggle时flag不生效，起初以为是flag的原因，结果是因为每次都生成了新的播放实例，在新的播放实例上调stop是无效的 calc运算符号是要空格的，要不然calc出不来; 小程序wxs出错弹层类型拿数据后会在真机直接奔溃，如果你确定template等传值都是对的，那么这个时候你需要看看wxs传入的值是否正确，这在控制台是不会报错的 列表点击弹出列表选取列表项逻辑应该是，点第一个列表时记录该列表项id，然后在第二个列表点确定时设置下一个id，并跑接口，取消则清空两个id； 生产环境小程序在打开时有两种情况，第一种是打开后到首页，这种无疑会触发onLaunch；还有一种是打开后进入其它页面然后关闭，再马上打开，这时还在之前显示的页面，这时并没有触发onLaunch; 小程序中innerAudioContext使用必须开启铃声状态才有声音哦,同时oncanplay可能会有问题 防止同时播放问题，保证运行的父组件中只有一个播放context，同时再播放前将其他全部标志设置为false cpm config set registry http://fjdsklajf.com; scss _前缀是用在一个文件不需要编译时，引入时可以去掉下划线 this.$parent就是app实例，在wepy的page中 调试一个框架的api，可以在方法里面console.log(arguments),看看需要传什么，然后可以相应知道怎么用 背景大圆弧可以用border-bottom-left-radius结合right来做，给具体的值 wepy中报找不到wxss目前发现了两个原因，第一子组件sass引用路径错误，第二命名使用了toast这种的保留组件名 小程序wepy框架 unexpected attribute near .sync(.once),检查是否在components中引入了组件 textarea的换行符，可以用white-space: pre-wrap显示生效 font-size，text-indent百分数值表示总是根据父元素继承的大小来计算，font-size可以继承（小程序button下子元素字体大小不能继承），继承的是计算值而不是百分数也就是计算了以后得到的具体的值，border，margin，padding，background不能继承，继承的值没有特殊性，连0都不如，比如通配选择器的样式就可以覆盖继承值 特殊性：id 0100 .some-class（类） *[alt]（属性选择器） :first-child（伪类） 0010 img :before（伪元素）0001 text-indent只用于块级元素（如果块级首行有一个图像，则图像也会移动），同时可以为负 margin-top,margin-bottom的百分数值是相对于父元素宽度而不是高度，否则会出现高度地狱 行内非替换元素上下位置的margin现实上与没有是一样，同时负外边距时，上下外边距和行高不受影响 输入框要加样式，占满整行，并且要有高度 子view有margin-top会有滚动条，可以flex column 和min-height 100%，来解决 line-height居中与flex居中不要混用 laya中居中一个元素可以用宽度除以2和高度除以2 小程序里面的模板消息需要表单支持 此文长期更新，遇到什么就写什么，mark","categories":[],"tags":[{"name":"工作","slug":"工作","permalink":"http://yoursite.com/tags/工作/"}]},{"title":"html标签","slug":"html标签","date":"2018-01-05T05:24:08.000Z","updated":"2018-01-05T05:40:43.981Z","comments":true,"path":"2018/01/05/html标签/","link":"","permalink":"http://yoursite.com/2018/01/05/html标签/","excerpt":"","text":"htmls所有标签 a abbr acronym address applet area article aside audio b base basefont bdi bdo bgsound big blink blockquote body br button canvas caption center cite code col colgroup command content data datalist dd del details dfn dialog dir div dl dt element em embed fieldset figcaption figure font footer form frame frameset h1~h6 head header hgroup hr html i iframe image(请勿使用，从未实现) img input ins isindex kbd keygen label legend li link listing main map mark marquee menu menuitem meta meter multicol nav nextid nobr noembed noframes noscript object ol optgroup option output p param picture plaintext pre progress q rp rt rtc ruby s samp script section select shadow slot small Source spacer span strike strong style sub summary sup table tbody td template textarea tfoot th thead time title tr track tt u ul var video wbr xmp","categories":[],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"JS对象漫谈","slug":"JS对象漫谈","date":"2017-11-26T04:18:14.000Z","updated":"2017-11-26T04:22:56.288Z","comments":true,"path":"2017/11/26/JS对象漫谈/","link":"","permalink":"http://yoursite.com/2017/11/26/JS对象漫谈/","excerpt":"","text":"如何转为number Number(‘1’) === 1 parseInt(‘1’, 10) === 1 parseFloat(‘1.23’) === 1.23 ‘1’ - 0 +‘1’ 全局对象window 浏览器在加载时首先会创建window对象 window的属性分为两类： ECMAScript规定的和浏览器私有的（alert，prompt，confirm，console, history, document等） document属于dom规范范畴 ,history属于bom规范范畴 详解Number Number(‘1’) 类型转换 var n = new Number(1) 1 =&gt; {valueOf(): 1,..},通过valueOf获取到原始值1 使用直接量赋值 var n = 1;在早期是没有toString方法的，而现在直接使用toString会临时转换为Number对象包装后的“1”然后使用toString，最后把这个包装对象丢掉（磨砂次）,这就是为什么给n.xxx = 1后，然后取n.xxx是undefined的原因 parseInt 与 toString进制问题 parseInt第二个形参传入一个进制，代表将第一个实参是什么进制的，然后转化为10进制输出 toString可以传入一个参数代表将要转化的进制，把调用者转化为对应进制的字符串 slice 为什么叫slice？外国人切面包叫slice，js slice可以“切”数组，字符串。 5个falsy值 0 NaN ‘’ null undefined false 所有对象都是真值 原型 var o1 = {}; o1.proto === Object.prototype var n1 = new Number(1) n1.proto === Number.prototype n1.proto.proto === Object.prototype proto 和 prototypeString.prototype是String的公用属性的引用 s.proto 也是String的公用属性的引用 var 对象 = new 函数(); 对象.proto === 函数.prototype 它们的值是 [Prototype] var obj = 函数.prototype obj.proto === Object.prototype var obj2 = 函数 obj2.proto === Function.prototype Function.proto === Function.prototype Function,prototype.proto === Object.prototype","categories":[],"tags":[]},{"title":"武汉光谷国际人工智能产业峰会","slug":"武汉光谷国际人工智能产业峰会","date":"2017-11-19T03:37:36.000Z","updated":"2018-02-13T02:08:36.623Z","comments":true,"path":"2017/11/19/武汉光谷国际人工智能产业峰会/","link":"","permalink":"http://yoursite.com/2017/11/19/武汉光谷国际人工智能产业峰会/","excerpt":"","text":"本文不探讨人工智能深入的知识，只是个人的一些感受与大家分享 人工智能的趋势 是不是治好了你的颈椎病？（逃） 人工智能强势登场记得会场上IEEE Fellow蔡自兴院士说了一句让我印象十分深刻话，他说年轻人不要偷懒哦，小心机器人取代你。对啊，随着人工智能的发展，计算机从计算到感知到认知，可以想象在将来的某一天，机器人也有情感，它将不再是一堆冰冷的钢铁，而是一个有趣的小伙或是一个小姑娘。 上面这幅图讲述了人工智能可能会替代的职业，从电话推销员到政府职员，涉及面覆盖的很广，我想这只是其中的一部分而不是全部。可见人工智能的威力。 why AI？互联网行业是近几年的热门，非计算机专业的人都想来这里捞一桶金，然而随着发展，互联网的流量能挣到的钱正在消失，维护的成本在日益增加。人工智能的处理代替传统人力工作，从一定程度上降低的这方面的成本，所以这是为什么目前国家在大力开展人工智能的建设的原因之一。 简单的AI思想现在有一个场景，国外有些职场人士每天喜欢喝热的咖啡，他们需要看咖啡机里的咖啡是否是满的，是否是热的，是否已经空了等等情况来做出加热，加水等操作，如果把这个交给人工智能来做，应该怎么做呢？ 会上讲到一种思路是使用value function on off full -2 -5 value function 左侧代表咖啡机是否装满了，右侧代表是否开启加热功能时的状态，用这种映射关系来指挥计算机。当函数的自变量为-2时，会得到一个状态：咖啡机满了且需要加热。 个人的奇思妙想如果机器人有了情感他会听人类的吗？ 比方说现在用生物技术做出了一种生物，你觉得你能很好的控制它么？ 这就像当老师管学生一样，老师说的大道理再多，学生会去执行吗？ 同理你每天命令有感情的计算机工作，它会不会厌烦了。 当然，这只是个人拙见，还待科学家解释。","categories":[],"tags":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/tags/AI/"}]},{"title":"开博大吉","slug":"开博大吉","date":"2017-11-18T11:40:30.000Z","updated":"2017-11-18T11:50:59.000Z","comments":true,"path":"2017/11/18/开博大吉/","link":"","permalink":"http://yoursite.com/2017/11/18/开博大吉/","excerpt":"","text":"开博大吉 一名初入行的小前端的个人博客,原博客地址博客园酱板鸡。 ​","categories":[],"tags":[{"name":"get started","slug":"get-started","permalink":"http://yoursite.com/tags/get-started/"}]},{"title":"Hexo食用教程","slug":"Hexo食用教程","date":"2017-11-18T11:00:30.000Z","updated":"2017-11-18T11:36:22.000Z","comments":true,"path":"2017/11/18/Hexo食用教程/","link":"","permalink":"http://yoursite.com/2017/11/18/Hexo食用教程/","excerpt":"","text":"安装 npm install -g hexo-cli 建站 hexo init &lt;你博客存储文件夹名字&gt; cd &lt;你博客存储文件夹名字&gt; npm i example npm init blog cd blog npm i 修改配置文件_config.yml deploy: ​ type: git ​ repo: 部署 npm install hexo-deployer-git –save hexo deploy 写作 hexo new //新建文章 hexo g //生成静态件 hexo deploy //发布 feel interesting?do it!","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}